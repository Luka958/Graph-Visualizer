/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./models/DefaultsModel.js":
/*!*********************************!*\
  !*** ./models/DefaultsModel.js ***!
  \*********************************/
/***/ ((module) => {

eval("// names of the vertexSVG and edgeSVG attributes are valid SVG properties\nvar vertexProps = {\n  fill: '#7b68ee',\n  stroke: '#1c0952',\n  'stroke-width': '2',\n  circle: {\n    r: 15\n  },\n  square: {\n    base: 30\n  },\n  rectangle: {\n    width: 40,\n    height: 30\n  },\n  triangle: {\n    base: 35\n  },\n  polygon: {\n    base: 20,\n    angles: 5\n  }\n};\nvar edgeProps = {\n  stroke: '#1c0952',\n  'stroke-width': '2',\n  'scale-loop': '0.2'\n};\nvar vertexSVG = {\n  shape: 'circle',\n  fill: '#7b68ee',\n  stroke: '#1c0952',\n  'stroke-width': '2',\n  r: '15'\n};\nvar edgeSVG = {\n  shape: 'path',\n  stroke: '#1c0952',\n  'stroke-width': '2',\n  'scale-loop': '0.2'\n};\nvar canvasProps = {\n  canvasType: 'grid',\n  gridType: 'single',\n  backgroundColor: '#fc8955',\n  gridColor: 'white',\n  thin: {\n    min: 0.5,\n    max: 5,\n    step: 0.5,\n    value: 1\n  },\n  wide: {\n    min: 1,\n    max: 10,\n    step: 0.5,\n    value: 2.5\n  }\n};\nmodule.exports = {\n  vertexProps: vertexProps,\n  edgeProps: edgeProps,\n  canvasProps: canvasProps,\n  vertexSVG: vertexSVG,\n  edgeSVG: edgeSVG\n};\n\n//# sourceURL=webpack://test_zav/./models/DefaultsModel.js?");

/***/ }),

/***/ "./public/scripts/algorithms/Dijkstra.js":
/*!***********************************************!*\
  !*** ./public/scripts/algorithms/Dijkstra.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Dijkstra)\n/* harmony export */ });\n/* harmony import */ var _decorators_animate_decorators_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decorators/animate.decorators.js */ \"./public/scripts/algorithms/decorators/animate.decorators.js\");\n/* harmony import */ var _decorators_addon_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decorators/addon.decorators.js */ \"./public/scripts/algorithms/decorators/addon.decorators.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nvar _class, _class2;\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\n\nvar Dijkstra = (_class = (_class2 = /*#__PURE__*/function () {\n  function Dijkstra() {\n    _classCallCheck(this, Dijkstra);\n  }\n  _createClass(Dijkstra, null, [{\n    key: \"run\",\n    value:\n    /*#__PURE__*/\n    /**\r\n     * @param containers contains all vertices and edges\r\n     * @param src source vertex\r\n     * @typedef {{id: number, neighbours: []}} src\r\n     */\n    _regeneratorRuntime().mark(function run(containers, src) {\n      var vertexContainer, edgeContainer, l, S, E, pairs, w, _iterator2, _step2, _v, i, min, _iterator3, _step3, v, _iterator4, _step4, u, d;\n      return _regeneratorRuntime().wrap(function run$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            w = function _w(u, v) {\n              var _iterator = _createForOfIteratorHelper(edgeContainer),\n                _step;\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  var edge = _step.value;\n                  if (edge.connection.includes(u.id) && edge.connection.includes(v.id)) {\n                    E.push(edge.id);\n                    return edge.weight;\n                  }\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              throw new Error('Provided vertices are not neighbours!');\n            };\n            vertexContainer = containers.vertexContainer, edgeContainer = containers.edgeContainer;\n            l = new Map(); // labels\n            S = new Set(); // vertex set\n            E = []; // animated edges\n            pairs = new Map(); // <vertex id, vertex id>\n            _iterator2 = _createForOfIteratorHelper(vertexContainer);\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                _v = _step2.value;\n                l.set(_v, _v === src ? 0 : Infinity);\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n            S.add(src);\n            i = 0;\n            _context.next = 12;\n            return {\n              i: i,\n              l: new Map(l),\n              S: new Set(S),\n              E: [],\n              v: src,\n              d: 0\n            };\n          case 12:\n            if (!(i < vertexContainer.length - 1)) {\n              _context.next = 57;\n              break;\n            }\n            min = {\n              v: undefined,\n              d: Infinity\n            };\n            _iterator3 = _createForOfIteratorHelper(_.difference(vertexContainer, Array.from(S)));\n            _context.prev = 15;\n            _iterator3.s();\n          case 17:\n            if ((_step3 = _iterator3.n()).done) {\n              _context.next = 42;\n              break;\n            }\n            v = _step3.value;\n            _iterator4 = _createForOfIteratorHelper(S);\n            _context.prev = 20;\n            _iterator4.s();\n          case 22:\n            if ((_step4 = _iterator4.n()).done) {\n              _context.next = 32;\n              break;\n            }\n            u = _step4.value;\n            if (u.neighbours.includes(v.id)) {\n              _context.next = 26;\n              break;\n            }\n            return _context.abrupt(\"continue\", 30);\n          case 26:\n            d = Math.min(l.get(v), l.get(u) + w(u, v));\n            if (!pairs.has(v.id) || d < l.get(v)) {\n              // save the first pair of vertices that created the smallest label (for animation)\n              pairs.set(v.id, u.id);\n            }\n            l.set(v, d);\n            if (d < min.d) {\n              min.d = d;\n              min.v = v;\n            }\n          case 30:\n            _context.next = 22;\n            break;\n          case 32:\n            _context.next = 37;\n            break;\n          case 34:\n            _context.prev = 34;\n            _context.t0 = _context[\"catch\"](20);\n            _iterator4.e(_context.t0);\n          case 37:\n            _context.prev = 37;\n            _iterator4.f();\n            return _context.finish(37);\n          case 40:\n            _context.next = 17;\n            break;\n          case 42:\n            _context.next = 47;\n            break;\n          case 44:\n            _context.prev = 44;\n            _context.t1 = _context[\"catch\"](15);\n            _iterator3.e(_context.t1);\n          case 47:\n            _context.prev = 47;\n            _iterator3.f();\n            return _context.finish(47);\n          case 50:\n            S.add(min.v);\n            i++;\n            _context.next = 54;\n            return {\n              i: i,\n              l: new Map(l),\n              S: new Set(S),\n              E: [].concat(E),\n              v: min.v,\n              d: min.d,\n              pair: [min.v.id, pairs.get(min.v.id)]\n            };\n          case 54:\n            E.length = 0;\n            _context.next = 12;\n            break;\n          case 57:\n            return _context.abrupt(\"return\", containers);\n          case 58:\n          case \"end\":\n            return _context.stop();\n        }\n      }, run, null, [[15, 44, 47, 50], [20, 34, 37, 40]]);\n    })\n  }, {\n    key: \"setSource\",\n    value: function setSource(src) {\n      Dijkstra.src = src;\n    }\n  }, {\n    key: \"manageAnimated\",\n    value: function () {\n      var _manageAnimated = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(containers, inStepMode) {\n        var val;\n        return _regeneratorRuntime().wrap(function _callee$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (Dijkstra.iterator === undefined) {\n                console.assert(Dijkstra.src !== undefined);\n                Dijkstra.iterator = Dijkstra.run(containers, Dijkstra.src);\n                Dijkstra.wasInStepMode = inStepMode;\n              }\n              val = Dijkstra.iterator.next();\n              if (val.done) Dijkstra.iterator = undefined;\n              if (!inStepMode) {\n                _context2.next = 5;\n                break;\n              }\n              return _context2.abrupt(\"return\");\n            case 5:\n              if (val.done) {\n                _context2.next = 17;\n                break;\n              }\n              _context2.next = 8;\n              return _decorators_animate_decorators_js__WEBPACK_IMPORTED_MODULE_0__.TimeManager.getInstance().delay();\n            case 8:\n              if (!(Dijkstra.wasInStepMode !== inStepMode)) {\n                _context2.next = 11;\n                break;\n              }\n              _context2.next = 11;\n              return _decorators_animate_decorators_js__WEBPACK_IMPORTED_MODULE_0__.TimeManager.getInstance().delay();\n            case 11:\n              Dijkstra.wasInStepMode = inStepMode;\n              val = Dijkstra.iterator.next();\n              _context2.next = 15;\n              return _decorators_animate_decorators_js__WEBPACK_IMPORTED_MODULE_0__.TimeManager.getInstance().delay();\n            case 15:\n              _context2.next = 5;\n              break;\n            case 17:\n              Dijkstra.wasInStepMode = inStepMode;\n              Dijkstra.iterator = undefined;\n            case 19:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee);\n      }));\n      function manageAnimated(_x, _x2) {\n        return _manageAnimated.apply(this, arguments);\n      }\n      return manageAnimated;\n    }()\n  }, {\n    key: \"managePerformance\",\n    value: function managePerformance(containers) {}\n  }]);\n  return Dijkstra;\n}(), _defineProperty(_class2, \"iterator\", void 0), _defineProperty(_class2, \"src\", void 0), _defineProperty(_class2, \"wasInStepMode\", void 0), _class2), (_applyDecoratedDescriptor(_class, \"run\", [_decorators_animate_decorators_js__WEBPACK_IMPORTED_MODULE_0__.Animate], Object.getOwnPropertyDescriptor(_class, \"run\"), _class), _applyDecoratedDescriptor(_class, \"managePerformance\", [_decorators_addon_decorators_js__WEBPACK_IMPORTED_MODULE_1__.Addon], Object.getOwnPropertyDescriptor(_class, \"managePerformance\"), _class)), _class);\n\n\n//# sourceURL=webpack://test_zav/./public/scripts/algorithms/Dijkstra.js?");

/***/ }),

/***/ "./public/scripts/algorithms/decorators/addon.decorators.js":
/*!******************************************************************!*\
  !*** ./public/scripts/algorithms/decorators/addon.decorators.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Addon\": () => (/* binding */ Addon)\n/* harmony export */ });\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction Addon(target, name, descriptor) {\n  var defaultDescriptor = descriptor.value;\n  descriptor.value = function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    defaultDescriptor.apply(this, args);\n    return call(args[0]);\n  };\n  return descriptor;\n}\nfunction call(containers) {\n  var req = new Request('/algorithm', {\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    method: 'POST',\n    body: JSON.stringify(containers)\n  });\n  fetch(req).then(function (res) {\n    return res.json();\n  }).then(function (res) {\n    table(res);\n    console.log(res);\n  });\n}\nfunction table(res) {\n  var div = document.querySelector('#results-div');\n  var heading = document.querySelector('#results-heading');\n  var content = document.querySelector('#results-content');\n  var table = '<table class=\"dijkstra-table\" style=\"width: 100%\"><tr><td></td>';\n  var _iterator = _createForOfIteratorHelper(res.result),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var start = _step.value;\n      table += \"<td class=\\\"dijkstra-first-row\\\">\".concat(start.startVertexId, \"</td>\");\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  table += '</tr>';\n  var _iterator2 = _createForOfIteratorHelper(res.result),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _start = _step2.value;\n      table += \"<tr><td class=\\\"dijkstra-first-column\\\">\".concat(_start.startVertexId, \"</td>\");\n      var _iterator3 = _createForOfIteratorHelper(_start.other),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var el = _step3.value;\n          table += \"<td>\".concat(el.distance, \"</td>\");\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      table += '</tr>';\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  table += '</table>';\n  if (res.duration >= 1000000 * 60 * 60) {\n    heading.innerText = \"Dijkstra (\".concat(res.duration / 1000000 * 60 * 60, \"h)\");\n  } else if (res.duration >= 1000000 * 60) {\n    heading.innerText = \"Dijkstra (\".concat(res.duration / 1000000 * 60, \"min)\");\n  } else if (res.duration >= 1000000) {\n    heading.innerText = \"Dijkstra (\".concat(res.duration / 1000000, \"s)\");\n  } else if (res.duration >= 1000) {\n    heading.innerText = \"Dijkstra (\".concat(res.duration / 1000, \"ms)\");\n  } else {\n    heading.innerText = \"Dijkstra (\".concat(res.duration, \"\\u03BCs)\");\n  }\n  content.innerHTML = table;\n  content.style.textAlign = 'center';\n  setVisible(div);\n}\n\n//# sourceURL=webpack://test_zav/./public/scripts/algorithms/decorators/addon.decorators.js?");

/***/ }),

/***/ "./public/scripts/algorithms/decorators/animate.decorators.js":
/*!********************************************************************!*\
  !*** ./public/scripts/algorithms/decorators/animate.decorators.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Animate\": () => (/* binding */ Animate),\n/* harmony export */   \"TimeManager\": () => (/* binding */ TimeManager)\n/* harmony export */ });\n/* harmony import */ var _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../models/DrawingHelperModel.js */ \"./public/scripts/models/DrawingHelperModel.js\");\n/* harmony import */ var _models_DefaultsModel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../models/DefaultsModel.js */ \"./models/DefaultsModel.js\");\n/* harmony import */ var _models_DefaultsModel_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_models_DefaultsModel_js__WEBPACK_IMPORTED_MODULE_1__);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\nvar COLOR = '#FFFF00';\nvar BASE_TIME = 1000; // time in ms\n\nvar TimeManager = /*#__PURE__*/function () {\n  function TimeManager() {\n    _classCallCheck(this, TimeManager);\n    _defineProperty(this, \"time\", BASE_TIME);\n  }\n  _createClass(TimeManager, [{\n    key: \"updateTime\",\n    value: function updateTime(factor) {\n      this.time *= factor;\n    }\n  }, {\n    key: \"getTime\",\n    value: function getTime() {\n      return this.time;\n    }\n  }, {\n    key: \"delay\",\n    value: function () {\n      var _delay = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this = this;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", new Promise(function (resolve) {\n                return setTimeout(resolve, _this.time);\n              }));\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      function delay() {\n        return _delay.apply(this, arguments);\n      }\n      return delay;\n    }()\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance() {\n      return TimeManager.instance;\n    }\n  }]);\n  return TimeManager;\n}();\n_defineProperty(TimeManager, \"instance\", new TimeManager());\nfunction Animate(target, name, descriptor) {\n  var defaultDescriptor = descriptor.value;\n  descriptor.value = function () {\n    var _marked = /*#__PURE__*/_regeneratorRuntime().mark(f);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    var generator = defaultDescriptor.apply(this, args);\n    function f() {\n      var result;\n      return _regeneratorRuntime().wrap(function f$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            if (false) {}\n            result = generator.next();\n            iteration(result);\n            if (!result.done) {\n              _context2.next = 5;\n              break;\n            }\n            return _context2.abrupt(\"return\", result.value);\n          case 5:\n            _context2.next = 7;\n            return result.value;\n          case 7:\n            _context2.next = 0;\n            break;\n          case 9:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _marked);\n    }\n    return f();\n  };\n  return descriptor;\n}\nfunction iteration(_ref) {\n  var value = _ref.value,\n    done = _ref.done;\n  if (done) {\n    setTimeout(function () {\n      value.vertexContainer.forEach(function (v) {\n        return defaultColorVertexByAttr((0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_0__.getVertexFromID)(v.id));\n      });\n      value.edgeContainer.forEach(function (e) {\n        return defaultColorEdgeByAttr((0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_0__.getEdgeFromID)(e.id));\n      });\n      removeLabelTexts(); // specific\n    }, TimeManager.getInstance().getTime());\n    return;\n  }\n  var v = value.v; // specific\n  var idsInS = _toConsumableArray(value.S).map(function (el) {\n    return el.id;\n  }); // specific\n  var _iterator = _createForOfIteratorHelper(value.E),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var edgeId = _step.value;\n      var edge = (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_0__.getEdgeFromID)(edgeId);\n      var connection = (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_0__.getConnection)(edge);\n      var v1Id = connection[0];\n      var v2Id = connection[1];\n      var reversed = !idsInS.includes(v1Id) || v1Id === v.id;\n      drawEdgeByAnimation(edge, reversed);\n      var chosen = value.pair.includes(v1Id) && value.pair.includes(v2Id); // specific\n      chosen ? colorEdgeByAttr(edge) : colorEdgeByAnimation(edge);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  setTimeout(function () {\n    var vertex = (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_0__.getVertexFromID)(v.id);\n    colorVertexByAttr(vertex);\n    addLabelText(vertex, value.d);\n  }, value.i === 0 ? 0 : TimeManager.getInstance().getTime());\n}\nfunction addLabelText(vertex, data) {\n  var x = vertex.getAttribute('CA-center-x');\n  var y = vertex.getAttribute('CA-center-y');\n  var bounds = vertex.getBoundingClientRect();\n  var offsetY = (bounds.bottom - bounds.top) / 2;\n  var text = document.createElementNS(SVG_NS_URI, \"text\");\n  text.setAttribute('id', \"text-algorithm-\".concat((0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_0__.getIDFromVertex)(vertex)));\n  text.setAttribute('dominant-baseline', 'middle');\n  text.setAttribute('text-anchor', 'middle');\n  text.setAttribute('font-size', '15px');\n  text.setAttribute('font-weight', 'normal');\n  text.setAttribute('fill', 'white');\n  text.setAttribute('pointer-events', 'none');\n  text.style.userSelect = 'none';\n  text.textContent = data.toString();\n  SVG_CANVAS.appendChild(text);\n  var textBounds = text.getBoundingClientRect();\n  SVG_CANVAS.removeChild(text);\n  var offsetTextY = (textBounds.bottom - textBounds.top) / 2;\n  text.setAttribute('x', x);\n  text.setAttribute('y', \"\".concat(parseInt(y) - offsetY - offsetTextY));\n  SVG_CANVAS.appendChild(text);\n}\nfunction removeLabelTexts() {\n  var labels = document.querySelectorAll('[id^=\"text-algorithm-\"]');\n  if (labels) {\n    labels.forEach(function (el) {\n      return SVG_CANVAS.removeChild(el);\n    });\n  }\n}\n\n/**\r\n * animation for drawing the edge\r\n * @param edge the edge which coordinates will be used for drawing\r\n * @param reversed <b>true</b> if the abs and rel coords are defined\r\n * in a way that matches a direction of the drawing, <b>false</b>\r\n * otherwise (coords must be inverted in order to draw in wanted direction)\r\n */\nfunction drawEdgeByAnimation(edge, reversed) {\n  var d = edge.getAttribute('d');\n  var matched = d.match(_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_0__.PATH_START_REGEX);\n  var animate = document.createElementNS(SVG_NS_URI, 'animate');\n  animate.setAttribute('attributeName', 'd');\n  animate.setAttribute('dur', \"\".concat(TimeManager.getInstance().getTime() / 1000, \"s\"));\n  animate.setAttribute('repeatCount', '1');\n  animate.setAttribute('begin', 'indefinite'); // prevent start on append\n\n  if (reversed) {\n    var d0 = matched[0];\n    var d1 = d.substring(d0.length);\n    var d0Arr = d0.trim().split(' ').slice(1).map(function (el) {\n      return parseInt(el);\n    });\n    var d1Arr = d1.trim().split(' ').slice(1).map(function (el) {\n      return parseInt(el);\n    });\n    console.assert(d0Arr.length === 2 && d1Arr.length === 2);\n    var dR0 = \"M \".concat(d0Arr[0] + d1Arr[0], \" \").concat(d0Arr[1] + d1Arr[1], \" \");\n    var dR11 = 'l 0 0';\n    var dR12 = \"l \".concat(-d1Arr[0], \" \").concat(-d1Arr[1]);\n    animate.setAttribute('values', dR0 + dR11 + '; ' + dR0 + dR12);\n    // todo loop (not needed for dijkstra)\n  } else {\n    var _d = matched[0];\n    var _d2 = 'l 0 0';\n    animate.setAttribute('values', _d + _d2 + '; ' + d);\n  }\n  animate.addEventListener('endEvent', function () {\n    edge.removeChild(animate);\n  });\n  edge.appendChild(animate);\n  animate.beginElement();\n}\nfunction colorEdgeByAnimation(edge) {\n  var animate = document.createElementNS(SVG_NS_URI, 'animate');\n  animate.setAttribute('attributeName', 'stroke');\n  animate.setAttribute('dur', \"\".concat(TimeManager.getInstance().getTime() / 1000, \"s\"));\n  animate.setAttribute('repeatCount', '1');\n  animate.setAttribute('begin', 'indefinite');\n  animate.setAttribute('values', COLOR);\n  animate.addEventListener('endEvent', function () {\n    return edge.removeChild(animate);\n  });\n  edge.appendChild(animate);\n  animate.beginElement();\n}\nfunction colorEdgeByAttr(edge) {\n  edge.setAttribute('stroke', COLOR);\n}\nfunction defaultColorEdgeByAttr(edge) {\n  edge.setAttribute('stroke', (_models_DefaultsModel_js__WEBPACK_IMPORTED_MODULE_1___default().edgeSVG.stroke));\n}\nfunction colorVertexByAttr(vertex) {\n  vertex.setAttribute('stroke', COLOR);\n}\nfunction defaultColorVertexByAttr(vertex) {\n  vertex.setAttribute('stroke', (_models_DefaultsModel_js__WEBPACK_IMPORTED_MODULE_1___default().vertexSVG.stroke));\n}\n\n//# sourceURL=webpack://test_zav/./public/scripts/algorithms/decorators/animate.decorators.js?");

/***/ }),

/***/ "./public/scripts/drawing.js":
/*!***********************************!*\
  !*** ./public/scripts/drawing.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./models/VertexModel.js */ \"./public/scripts/models/VertexModel.js\");\n/* harmony import */ var _models_EdgeModel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./models/EdgeModel.js */ \"./public/scripts/models/EdgeModel.js\");\n/* harmony import */ var _models_AlgorithmModel_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./models/AlgorithmModel.js */ \"./public/scripts/models/AlgorithmModel.js\");\n/* harmony import */ var _models_DeleteEdgeModel_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./models/DeleteEdgeModel.js */ \"./public/scripts/models/DeleteEdgeModel.js\");\n/* harmony import */ var _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./models/ToolEnumModel.js */ \"./public/scripts/models/ToolEnumModel.js\");\n/* harmony import */ var _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./models/DrawingHelperModel.js */ \"./public/scripts/models/DrawingHelperModel.js\");\n/* harmony import */ var _models_JSONExtensionModel_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./models/JSONExtensionModel.js */ \"./public/scripts/models/JSONExtensionModel.js\");\n/* harmony import */ var _models_DrawingConstraintModel_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./models/DrawingConstraintModel.js */ \"./public/scripts/models/DrawingConstraintModel.js\");\n/* harmony import */ var _helpers_shrink_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./helpers/shrink.js */ \"./public/scripts/helpers/shrink.js\");\n/* harmony import */ var _helpers_color_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./helpers/color.js */ \"./public/scripts/helpers/color.js\");\n/* harmony import */ var _helpers_sketch_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./helpers/sketch.js */ \"./public/scripts/helpers/sketch.js\");\n/* harmony import */ var _models_ScreenshotModel_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./models/ScreenshotModel.js */ \"./public/scripts/models/ScreenshotModel.js\");\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n_models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.Vertex.initVertexSVG();\n_models_EdgeModel_js__WEBPACK_IMPORTED_MODULE_1__.Edge.initEdgeSVG();\nconsole.log(_models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.Vertex.vertexSVG, _models_EdgeModel_js__WEBPACK_IMPORTED_MODULE_1__.Edge.edgeSVG);\n\n// an arrow scaling formula for adjustment of the arrow size depending on edge width\nvar SCALE_ARROW = 0.5 * (Math.log(parseInt(_models_EdgeModel_js__WEBPACK_IMPORTED_MODULE_1__.Edge.edgeSVG[\"stroke-width\"].toString()) + 0.5) / Math.log(2.5));\ndocument.querySelector('#save-vertex').onclick = function () {\n  document.querySelector('#vertex-properties').style.visibility = 'hidden';\n  _models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.Vertex.updateVertexSVG();\n};\ndocument.querySelector('#save-edge').onclick = function () {\n  document.querySelector('#edge-properties').style.visibility = 'hidden';\n  _models_EdgeModel_js__WEBPACK_IMPORTED_MODULE_1__.Edge.updateEdgeSVG();\n};\n\n/**\r\n * storing all vertices that are visible in canvas\r\n * @type {Map<any, any>} - key: vertex, value: drawEdge function\r\n */\nvar map = new Map();\n/**\r\n * contains vertices which drawEdge listeners must be removed before drawing edges\r\n * because they will get the new ones, after drawing edge functionality is activated\r\n * @type {Map<any, any>} - key: old vertex, value: [new vertex, drawEdge]\r\n */\nvar keysToRemove = new Map();\n\n/**\r\n * used for mechanism of preventing addition of\r\n * multiple rotate event listeners of the same kind\r\n * @type {Map<any, any>} key: loop id, value: rotate event listener\r\n */\nvar map2 = new Map();\n\n// storing all vertices and edges\nvar vertexContainer = [],\n  edgeContainer = [];\nfunction getVertexContainer() {\n  vertexContainer = Array.from(map.keys());\n  return vertexContainer;\n}\nfunction getEdgeContainer() {\n  return edgeContainer;\n}\nfunction getFromContainer(ID, container) {\n  console.assert(!isNaN(ID));\n  var element = null;\n  container.forEach(function (el) {\n    if (el.id === ID) element = el;\n  });\n  return element;\n}\nfunction removeFromContainer(ID, container) {\n  console.assert(!isNaN(ID));\n  container.splice(container.findIndex(function (el) {\n    return el.id === ID;\n  }), 1);\n}\nvar updateVerticesPos = function updateVerticesPos() {\n  keysToRemove.forEach(function (value, key) {\n    map[\"delete\"](key);\n    map.set(value[0], value[1]);\n  });\n  keysToRemove.clear();\n};\nvar canvas = document.querySelector('.canvas');\nvar connector = {\n  v1: undefined,\n  v2: undefined\n}; // v1, v2 - vertices that are going to be connected\n\n// ------------ listening for graph type changes ------------ //\nvar graphType1 = document.querySelector('#select-graph-type-1');\nvar isDirected;\ngraphType1.value === 'directed' ? isDirected = true : isDirected = false;\ngraphType1.addEventListener('change', function () {\n  graphType1.value === 'directed' ? isDirected = true : isDirected = false;\n});\nvar graphType2 = document.querySelector('#select-graph-type-2');\nvar isWeighted;\ngraphType2.value === 'weighted' ? isWeighted = true : isWeighted = false;\ngraphType2.addEventListener('change', function () {\n  graphType2.value === 'weighted' ? isWeighted = true : isWeighted = false;\n});\nvar weightSaved = false;\n// ---------------------------------------------------------- //\n\nvar vertexBtn = document.querySelector('#draw-vertex');\nvar edgeBtn = document.querySelector('#draw-edge');\nvar moveBtn = document.querySelector('#operation-img-1');\nvar rotateBtn = document.querySelector('#operation-img-2');\nvar clearBtn = document.querySelector('#operation-img-3');\nvar deleteBtn = document.querySelector('#operation-img-4');\nvar reverseBtn = document.querySelector('#operation-img-5');\nvar weightBtn = document.querySelector('#operation-img-6');\nvar shrinkBtn = document.querySelector('#operation-img-7');\nvar expandBtn = document.querySelector('#operation-img-8');\nvar screenshotBtn = document.querySelector('#operation-img-9');\nvar sketchBtn = document.querySelector('#operation-img-10');\nvar colorBtn = document.querySelector('#operation-img-11');\n\n// not part of the toolbar\nvar confirmExportBtn = document.querySelector('#confirm-export-button');\nvar buttons = [vertexBtn, edgeBtn, moveBtn, rotateBtn, clearBtn, deleteBtn, reverseBtn, weightBtn, shrinkBtn, expandBtn, screenshotBtn, sketchBtn, colorBtn];\n\n// the following are menu buttons, they are not part of the toolbar as the buttons above\nvar cancelWeightBtn = document.querySelector('#cancel-weight-button');\nvar saveWeightBtn = document.querySelector('#save-weight-button');\n\n/**\r\n * set color of activatedButton that was clicked last\r\n * @param activatedButton\r\n */\nvar setButtonColor = function setButtonColor(activatedButton) {\n  buttons.forEach(function (button) {\n    return button !== activatedButton ? button.style.backgroundColor = '#fedbcd' : button.style.backgroundColor = 'white';\n  });\n};\n\n// do something when toolActive.current changes\n_models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.registerListener(function () {\n  if (_models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current === _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.UNDEFINED) {\n    setButtonColor(null);\n  }\n  // update vertices position whenever you are done with moving them\n  if (_models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current !== _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.MOVE && _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.previous === _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.MOVE) {\n    updateVerticesPos();\n  }\n  if (_models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current !== _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.DRAW_EDGE && connector.v1 !== undefined) {\n    connector.v1 = undefined;\n  }\n  if (_models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current !== _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.ROTATE && _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.previous === _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.ROTATE) {\n    var helpTriangle = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getAll('[id^=\"triangle-rotate-\"]');\n    var helpCircle = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getAll('[id^=\"circle-rotate-\"]');\n    if (helpTriangle !== null) helpTriangle.forEach(function (el) {\n      return el.remove();\n    });\n    if (helpCircle !== null) helpCircle.forEach(function (el) {\n      return el.remove();\n    });\n    var loops = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getAll('[CA-type*=\"loop\"]');\n    loops.forEach(function (loop) {\n      _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.loopToVertex(loop).removeEventListener('click', map2.get(_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getIDFromEdge(loop)));\n    });\n    map2.clear();\n  }\n  if (_models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current !== _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.WEIGHT && _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.previous === _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.WEIGHT) {\n    // remove all elements from table\n    var table = document.querySelector('#weight-table');\n    while (table.firstChild) {\n      table.removeChild(table.firstChild);\n    }\n  }\n  if (_models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current !== _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.DELETE && _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.previous === _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.DELETE) {\n    _models_DeleteEdgeModel_js__WEBPACK_IMPORTED_MODULE_3__.removeWrappers();\n  }\n});\n\n/**\r\n * creating new Vertex object, SVGVertexElement, SVGTextElement and\r\n * listener for drawing edges with given event (click)\r\n * @param event\r\n */\nvar drawVertexListener = function drawVertexListener(event) {\n  if (_models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current !== _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.DRAW_VERTEX) return;\n  var canvasOffset = canvas.getBoundingClientRect();\n  var x = event.clientX - canvasOffset.left; // taking care of canvas offset\n  var y = event.clientY - canvasOffset.top;\n  var vertex = new _models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.Vertex(x, y, _models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.Vertex.updateVertexSVG());\n  if (vertex.shape === 'circle') {\n    // (cx, cy) are exact coordinates\n    vertex.SVG['cx'] = x;\n    vertex.SVG['cy'] = y;\n  } else if (vertex.shape === 'rect') {\n    // (x, y) are inner top left coordinates, offset is not needed\n    vertex.SVG['x'] = x - parseInt(_models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.Vertex.vertexSVG.width) / 2;\n    vertex.SVG['y'] = y - parseInt(_models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.Vertex.vertexSVG.height) / 2;\n  } else {\n    // includes polygon and triangle\n    vertex.SVG.points = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.findPolygonPoints(x, y, vertex.SVG['polygon-base'], vertex.SVG['number-of-angles']);\n  }\n  var drawEdge = function drawEdge(event) {\n    return drawEdgeListener(event, vertex);\n  };\n  map.set(vertex, drawEdge);\n  var SVGVertexElement = vertex.createVertex();\n  canvas.appendChild(SVGVertexElement);\n  var SVGTextElement = vertex.addText();\n  canvas.appendChild(SVGTextElement);\n  console.log(SVGVertexElement);\n};\ncanvas.addEventListener('click', drawVertexListener);\n\n/**\r\n * drawing edges using connector object that consists of two vertices,\r\n * we are assigning vertices to undefined values, otherwise create edge\r\n * @param event\r\n * @param vertex - vertex that got clicked after choosing tool for drawing edges\r\n */\nvar drawEdgeListener = function drawEdgeListener(event, vertex) {\n  if (_models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current !== _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.DRAW_EDGE) return;\n  if (connector.v1 === undefined) {\n    connector.v1 = vertex;\n  } else if (connector.v2 === undefined) {\n    connector.v2 = vertex;\n    var edge = _models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.createEdge(connector.v1, connector.v2, _models_EdgeModel_js__WEBPACK_IMPORTED_MODULE_1__.Edge.edgeSVG, isDirected, isWeighted);\n    canvas.append(edge);\n    _models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.restore(_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getVertexFromID(connector.v1.id), _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getVertexFromID(connector.v2.id), _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getTextFromID(connector.v1.id), _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getTextFromID(connector.v2.id));\n    // creating ordinary (non-SVG) Edge object (needed for algorithms, not DOM manipulation)\n    var edgeObjType;\n    connector.v1 === connector.v2 ? isDirected ? edgeObjType = _models_EdgeModel_js__WEBPACK_IMPORTED_MODULE_1__.Type.DIRECTED_LOOP : edgeObjType = _models_EdgeModel_js__WEBPACK_IMPORTED_MODULE_1__.Type.UNDIRECTED_LOOP : isDirected ? edgeObjType = _models_EdgeModel_js__WEBPACK_IMPORTED_MODULE_1__.Type.DIRECTED_LINE : edgeObjType = _models_EdgeModel_js__WEBPACK_IMPORTED_MODULE_1__.Type.UNDIRECTED_LINE;\n    var edgeObj = new _models_EdgeModel_js__WEBPACK_IMPORTED_MODULE_1__.Edge(parseInt(edge.getAttribute('id').split('edge-id-')[1]), edgeObjType, false, edge.getAttribute('CA-connection').split(',').map(Number));\n    getEdgeContainer().forEach(function (obj) {\n      // sets adjacency, but it won't set the loop to be adjacent to itself,\n      // because it is impossible by the definition\n      if (_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.countCommonElements(obj.connection, edgeObj.connection) > 0) {\n        // adding ids to adjacency of both edges\n        edgeObj.addAdjacent(obj.id);\n        obj.addAdjacent(edgeObj.id);\n      }\n    });\n    edgeContainer.push(edgeObj);\n\n    // creating arrow if graph is directed\n    if (edgeObj.type === _models_EdgeModel_js__WEBPACK_IMPORTED_MODULE_1__.Type.DIRECTED_LOOP) {\n      canvas.append(_models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.getArrowForLoop(edgeObj.id, connector.v1.x, connector.v1.y, _models_EdgeModel_js__WEBPACK_IMPORTED_MODULE_1__.Edge.edgeSVG, SCALE_ARROW));\n    } else if (edgeObj.type === _models_EdgeModel_js__WEBPACK_IMPORTED_MODULE_1__.Type.DIRECTED_LINE) {\n      canvas.append(_models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.getArrowForLine(edgeObj.id, connector.v1.x, connector.v1.y, connector.v2.x, connector.v2.y, _models_EdgeModel_js__WEBPACK_IMPORTED_MODULE_1__.Edge.edgeSVG, SCALE_ARROW));\n      _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.updateArrowOnCreate(edgeObj.id);\n      _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.updateArrowOnLineMove(edgeObj.id, isWeighted);\n    }\n    // reset connector\n    connector = {\n      v1: undefined,\n      v2: undefined\n    };\n    // whenever new edge is added, we are missing weight for that edge\n    if (isWeighted) {\n      weightSaved = false;\n    }\n    console.log(edge);\n  }\n};\nvertexBtn.addEventListener('click', function () {\n  _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current = _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.DRAW_VERTEX;\n  setButtonColor(vertexBtn);\n  map.forEach(function (value, key) {\n    _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getVertexFromID(key.id).removeEventListener('click', value);\n  });\n});\nedgeBtn.addEventListener('click', function () {\n  _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current = _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.DRAW_EDGE;\n  setButtonColor(edgeBtn);\n  map.forEach(function (value, key) {\n    _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getVertexFromID(key.id).addEventListener('click', value);\n  });\n});\nmoveBtn.addEventListener('click', function () {\n  _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current = _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.MOVE;\n  setButtonColor(moveBtn);\n  map.forEach(function (value, key) {\n    var SVGVertexElement = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getVertexFromID(key.id);\n    var relativeX, relativeY;\n    SVGVertexElement.addEventListener('mousedown', function () {\n      if (_models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current !== _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.MOVE) return;\n      var incidentEdges = new Map(); // key: edge-id, value: '1' or '2' (two ends of the edge)\n      // disable moving on the mouse click release\n      document.onmouseup = function () {\n        return document.onmouseup = document.onmousemove = null;\n      };\n\n      // move html SVGVertexElement when the cursor moves\n      document.onmousemove = function (eventMove) {\n        var canvasOffset = canvas.getBoundingClientRect();\n        relativeX = eventMove.clientX - canvasOffset.left;\n        relativeY = eventMove.clientY - canvasOffset.top;\n\n        // moving outside the canvas is forbidden\n        if (!(0,_models_DrawingConstraintModel_js__WEBPACK_IMPORTED_MODULE_7__.isAllowedByVertexSize)(eventMove.clientX, eventMove.clientY, SVGVertexElement, canvasOffset)) {\n          return;\n        }\n\n        /********** update SVGEdgeElement position **********/\n        var edges = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getAll('[id^=\"edge-id-\"]').filter(function (edge) {\n          return edge.getAttribute('CA-connection') // returns IDs separated by a comma\n          .split(',').includes(\"\".concat(key.id));\n        });\n        edges.forEach(function (edge) {\n          var edgeID = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getIDFromEdge(edge);\n          var type = edge.getAttribute('CA-type');\n          if (type === 'loop') {\n            _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.moveLoop(edge, relativeX, relativeY);\n          } else if (type === 'line') {\n            // we are changing coordinates of edge that are the same as vertex we are moving\n            // i.e. don't change coordinates of wrong end\n            var _Help$getPointsFromLi = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getPointsFromLine(edge),\n              _Help$getPointsFromLi2 = _slicedToArray(_Help$getPointsFromLi, 4),\n              x1 = _Help$getPointsFromLi2[0],\n              y1 = _Help$getPointsFromLi2[1],\n              x2 = _Help$getPointsFromLi2[2],\n              y2 = _Help$getPointsFromLi2[3];\n\n            // (key.x, key.y) - coordinates of the moving vertex\n            if (x1 === key.x && y1 === key.y || incidentEdges.get(edgeID) === '1') {\n              edge.setAttribute('d', _models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.getUndirectedLine(relativeX, relativeY, x2 + x1 - relativeX,\n              // +x1 to get old abs. pos., -relativeX to get new rel. pos.\n              y2 + y1 - relativeY));\n              incidentEdges.set(edgeID, '1');\n            } else if (x1 + x2 === key.x && y1 + y2 === key.y || incidentEdges.get(edgeID) === '2') {\n              edge.setAttribute('d', _models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.getUndirectedLine(x1, y1, relativeX - x1,\n              // -x1 to get new rel. pos.\n              relativeY - y1));\n              incidentEdges.set(edgeID, '2');\n            } else {\n              throw new Error(\"Vertex and Edge coordinates of SVG components don't \" + \"match in Tool.MOVE!\");\n            }\n          } else if (type === 'arc') {\n            var _Help$getPointsFromAr = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getPointsFromArc(edge),\n              _Help$getPointsFromAr2 = _slicedToArray(_Help$getPointsFromAr, 4),\n              _x2 = _Help$getPointsFromAr2[0],\n              _y = _Help$getPointsFromAr2[1],\n              _x3 = _Help$getPointsFromAr2[2],\n              _y2 = _Help$getPointsFromAr2[3];\n            // height of the control point (distance between control point and middle between vertices)\n            var h = parseFloat(edge.getAttribute('CA-h'));\n            // inverse attribute (draw arc up or down)\n            var inv = edge.getAttribute('CA-inv') === 'true';\n            if (_x2 === key.x && _y === key.y || incidentEdges.get(edgeID) === '1') {\n              edge.setAttribute('d', _models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.getUndirectedArc(relativeX, relativeY, _x3 + _x2 - relativeX, _y2 + _y - relativeY, h, inv));\n              incidentEdges.set(edgeID, '1');\n            } else if (_x2 + _x3 === key.x && _y + _y2 === key.y || incidentEdges.get(edgeID) === '2') {\n              edge.setAttribute('d', _models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.getUndirectedArc(_x2, _y, relativeX - _x2, relativeY - _y, h, inv));\n              incidentEdges.set(edgeID, '2');\n            } else {\n              throw new Error(\"Vertex and Edge coordinates of SVG components don't \" + \"match in Tool.MOVE!\");\n            }\n          }\n          /********** update SVGArrowElement position **********/\n          // is graph is directed, arrow has to be both rotated and translated\n          if (isDirected) {\n            getEdgeContainer().forEach(function (e) {\n              if (e.id === _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getIDFromEdge(edge)) {\n                if (e.type === _models_EdgeModel_js__WEBPACK_IMPORTED_MODULE_1__.Type.DIRECTED_LINE) {\n                  _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.updateArrowOnLineMove(e.id, isWeighted);\n                } else {\n                  var arrowOffset = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getArrowFromID(edgeID).getBoundingClientRect();\n                  var loopOffset = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getEdgeFromID(edgeID).getBoundingClientRect();\n                  if ((0,_models_DrawingConstraintModel_js__WEBPACK_IMPORTED_MODULE_7__.isAllowedByArrowSize)(arrowOffset, canvasOffset, loopOffset)) {\n                    _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.updateArrowOnLoopMove(e.id, isDirected, isWeighted);\n                  }\n                }\n              }\n            });\n          }\n          /********** update WeightItems position **********/\n          if (isWeighted && weightSaved) {\n            var weightItemOffset = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getWeightItemFromID(edgeID).getBoundingClientRect();\n            var loopOffset = edge.getBoundingClientRect();\n            if ((0,_models_DrawingConstraintModel_js__WEBPACK_IMPORTED_MODULE_7__.isAllowedByWeightItemSize)(weightItemOffset, canvasOffset, loopOffset)) {\n              _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.updateWeightOnMove(edgeID);\n            }\n          }\n        });\n        /********** update SVGVertexElement position **********/\n        switch (key.shape) {\n          case 'circle':\n            SVGVertexElement.setAttributeNS(null, 'cx', \"\".concat(relativeX));\n            SVGVertexElement.setAttributeNS(null, 'cy', \"\".concat(relativeY));\n            break;\n          case 'rect':\n            SVGVertexElement.setAttributeNS(null, 'x', \"\".concat(relativeX - parseInt(_models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.Vertex.vertexSVG.width) / 2));\n            SVGVertexElement.setAttributeNS(null, 'y', \"\".concat(relativeY - parseInt(_models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.Vertex.vertexSVG.height) / 2));\n            break;\n          case 'polygon':\n            SVGVertexElement.setAttributeNS(null, 'points', _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.findPolygonPoints(relativeX, relativeY, key.SVG['polygon-base'], key.SVG['number-of-angles']));\n            break;\n        }\n        /********** update SVGVertexElement center **********/\n        SVGVertexElement.setAttribute('CA-center-x', \"\".concat(relativeX));\n        SVGVertexElement.setAttribute('CA-center-y', \"\".concat(relativeY));\n        /********** update SVGTextElement position **********/\n        var text = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getTextFromID(key.id);\n        text.setAttribute('x', \"\".concat(relativeX));\n        text.setAttribute('y', \"\".concat(relativeY + _models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.TEXT_Y_OFFSET));\n      };\n    });\n    SVGVertexElement.addEventListener('mouseup', function () {\n      if (_models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current === _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.MOVE) {\n        // shallow copy (deep copy would throw an error because of circular reference)\n        var newKey = Object.assign(key);\n        newKey.x = relativeX;\n        newKey.y = relativeY;\n        var newValue = function newValue(event) {\n          return drawEdgeListener(event, newKey);\n        };\n        keysToRemove.set(key, [newKey, newValue]);\n        // remove old drawEdgeListener because position has changed\n        _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getVertexFromID(key.id).removeEventListener('click', map.get(key));\n      }\n    });\n  });\n});\nvar rotateListener = function rotateListener(vertex, loop, loopID, addedHelpCircle) {\n  if (_models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current !== _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.ROTATE) return;\n  var _Help$rotateLoopSetup = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.rotateLoopSetup(vertex, loop),\n    _Help$rotateLoopSetup2 = _slicedToArray(_Help$rotateLoopSetup, 2),\n    helpCircle = _Help$rotateLoopSetup2[0],\n    helpTriangle = _Help$rotateLoopSetup2[1];\n  if (!addedHelpCircle.val) {\n    canvas.append(helpCircle, helpTriangle);\n    addedHelpCircle.val = true;\n  } else {\n    canvas.append(helpTriangle);\n  }\n  helpTriangle.addEventListener('mousedown', function () {\n    document.onmouseup = function () {\n      return document.onmouseup = document.onmousemove = null;\n    };\n    document.onmousemove = function (event) {\n      var canvasOffset = canvas.getBoundingClientRect();\n      _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.rotateLoop(loopID, event.clientX - canvasOffset.left, event.clientY - canvasOffset.top, helpTriangle, helpCircle, isDirected, isWeighted);\n      if (isWeighted && weightSaved) {\n        _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.updateWeightOnMove(loopID);\n      }\n    };\n  });\n};\nrotateBtn.addEventListener('click', function () {\n  _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current = _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.ROTATE;\n  setButtonColor(rotateBtn);\n  /**\r\n   * key: vertexID, value: array of loopIDs that belong to vertex (vertex has multiple loops)\r\n   * @type {Map<Number, Array.<Number>>}\r\n   */\n  var multiLoopMap = new Map();\n  var vertexIds = getVertexContainer().map(function (el) {\n    return el.id;\n  });\n  vertexIds.forEach(function (id) {\n    var loops = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getAll('[CA-type*=\"loop\"]');\n    loops.forEach(function (loop) {\n      // connections are the same, so we can use any index (0 or 1)\n      var vertexID = parseInt(loop.getAttribute('CA-connection').split(',')[0]);\n      var loopID = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getIDFromEdge(loop);\n      if (id === vertexID) {\n        if (multiLoopMap.has(id)) {\n          var val = multiLoopMap.get(id);\n          val.push(loopID);\n          multiLoopMap.set(id, val);\n        } else {\n          multiLoopMap.set(id, [loopID]);\n        }\n      }\n    });\n  });\n  multiLoopMap.forEach(function (loopIDs, vertexID) {\n    var vertex = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getVertexFromID(vertexID);\n    // using object instead of the variable because of the need to save changes\n    // that are going to occur in rotateListener\n    var addedHelpCircle = {\n      val: false\n    };\n    loopIDs.forEach(function (loopID) {\n      var loop = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getEdgeFromID(loopID);\n      try {\n        vertex.removeEventListener('click', map2.get(loopID));\n      } catch (err) {}\n      var callRotateListener = function callRotateListener() {\n        return rotateListener(vertex, loop, loopID, addedHelpCircle);\n      };\n      vertex.addEventListener('click', callRotateListener);\n      map2.set(loopID, callRotateListener);\n    });\n  });\n});\nclearBtn.addEventListener('click', function () {\n  _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current = _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.CLEAR;\n  setButtonColor(clearBtn);\n  var confirm = document.querySelector('#confirm-clear-canvas-button');\n  confirm.addEventListener('click', function () {\n    clearCanvas();\n    _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current = _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.UNDEFINED;\n  });\n  var cancel = document.querySelector('#cancel-clear-canvas-button');\n  cancel.addEventListener('click', function () {\n    _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current = _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.UNDEFINED;\n  });\n});\ndeleteBtn.addEventListener('click', function () {\n  _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current = _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.DELETE;\n  setButtonColor(deleteBtn);\n  _models_DeleteEdgeModel_js__WEBPACK_IMPORTED_MODULE_3__.setWrappers(getEdgeContainer());\n\n  // delete vertex, incident edges and arrows after click on the vertex\n  getVertexContainer().forEach(function (vertex) {\n    if (vertex.helper.hasDeleteListener) return;\n    var SVGVertexElement = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getVertexFromID(vertex.id);\n    var deleteListener = function deleteListener() {\n      // we are always checking this conditions because we are not going to remove this listener\n      if (_models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current !== _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.DELETE) return;\n      if (vertex.neighbours.length > 0) {\n        _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getAll('[id^=\"edge-id-\"]').forEach(function (SVGEdgeElement) {\n          var ids = SVGEdgeElement.getAttribute('CA-connection').split(',');\n          // we are using `${ vertex.id }` because vertex.id is integer, array ids contains strings\n          if (ids.includes(\"\".concat(vertex.id))) {\n            var edgeID = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getIDFromEdge(SVGEdgeElement);\n            // removing SVGEdgeElement from canvas\n            SVGEdgeElement.remove();\n            // remove delete edge wrapper\n            _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getDeleteEdgeFromID(edgeID).remove();\n\n            // update the adjacent arrays of the edges\n            // that were adjacent to the deleted edge\n            var edge = getFromContainer(edgeID, edgeContainer);\n            edge.adjacent.forEach(function (eID) {\n              var e = getFromContainer(eID, edgeContainer);\n              e.adjacent.splice(e.adjacent.findIndex(function (e) {\n                return e === edgeID;\n              }), 1);\n            });\n            // removing Edge object from edgeContainer\n            removeFromContainer(edgeID, edgeContainer);\n            // removing SVGArrowElement from canvas\n            if (isDirected) {\n              _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getArrowFromID(edgeID).remove();\n            }\n            if (isWeighted) {\n              // performing null check because weights may not be added yet\n              var weightItem = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getWeightItemFromID(edgeID);\n              if (weightItem !== null) weightItem.remove();\n              var weightText = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getWeightTextFromID(edgeID);\n              if (weightText !== null) weightText.remove();\n            }\n          }\n        });\n      }\n      SVGVertexElement.remove(); // removing SVGVertexElement from canvas\n      map[\"delete\"](vertex); // removing Vertex object from map\n      // remove associated text\n      _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getTextFromID(vertex.id).remove();\n\n      // update the neighbours arrays of the vertices that were neighbour to\n      // the deleted vertex, using vertexContainer instead of getVertexContainer()\n      // to avoid altering the array during iteration\n      vertex.neighbours.forEach(function (vID) {\n        var v = getFromContainer(vID, vertexContainer);\n        if (v.neighbours !== null) {\n          v.neighbours.splice(v.neighbours.findIndex(function (v) {\n            return v === vertex.id;\n          }), 1);\n        }\n      });\n      removeFromContainer(vertex.id, vertexContainer);\n    };\n    SVGVertexElement.addEventListener('click', deleteListener);\n    vertex.helper.hasDeleteListener = true;\n  });\n\n  // delete edge and arrow after click on the edge\n  getEdgeContainer().forEach(function (edge) {\n    if (edge.helper.hasDeleteListener) return;\n    var SVGEdgeElement = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getEdgeFromID(edge.id);\n    SVGEdgeElement.addEventListener('click', function () {\n      if (_models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current !== _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.DELETE) return;\n      if (isDirected) {\n        _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getArrowFromID(edge.id).remove();\n      }\n      if (isWeighted) {\n        _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getWeightItemFromID(edge.id).remove();\n        _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getWeightTextFromID(edge.id).remove();\n      }\n      // update neighbours of the vertices that are connected by the edge that will be deleted\n      var connection = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getConnection(SVGEdgeElement);\n      var v1ID = connection[0];\n      var v2ID = connection[1];\n      var v1 = getFromContainer(v1ID, vertexContainer);\n      var v2 = getFromContainer(v2ID, vertexContainer);\n      if (v1ID !== v2ID) {\n        v1.neighbours.splice(v1.neighbours.findIndex(function (id) {\n          return id === v2ID;\n        }), 1);\n      }\n      v2.neighbours.splice(v2.neighbours.findIndex(function (id) {\n        return id === v1ID;\n      }), 1);\n      SVGEdgeElement.remove();\n      // remove delete edge wrapper\n      _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getDeleteEdgeFromID(edge.id).remove();\n      edge.adjacent.forEach(function (eID) {\n        var e = getFromContainer(eID, edgeContainer);\n        e.adjacent.splice(e.adjacent.findIndex(function (e) {\n          return e === edge.id;\n        }), 1);\n      });\n      removeFromContainer(edge.id, edgeContainer);\n    });\n    edge.helper.hasDeleteListener = true;\n  });\n});\n\n/**\r\n * array of the edge ids that already have reverse listener attached\r\n * @type {*[]}\r\n */\nvar arrowIDsWithReverseListener = [];\nreverseBtn.addEventListener('click', function () {\n  if (isDirected) {\n    _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current = _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.DIRECTION;\n    setButtonColor(reverseBtn);\n\n    // removing keys from array for edges (arrows) that got deleted,\n    // edge ids are always the same as arrow ids\n    var allArrowIds = getEdgeContainer().map(function (edge) {\n      return edge.id;\n    });\n    _.difference(arrowIDsWithReverseListener, allArrowIds).forEach(function (key) {\n      _.remove(arrowIDsWithReverseListener, function (id) {\n        return id === key;\n      });\n    });\n    getEdgeContainer().forEach(function (edge) {\n      var SVGArrowElement = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getArrowFromID(edge.id);\n      var SVGEdgeElement = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getEdgeFromID(edge.id);\n      var reverseListener = function reverseListener() {\n        _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.changeArrowDirection(edge.id);\n        var type = SVGEdgeElement.getAttribute('CA-type');\n        if (type === 'line' || type === 'arc') {\n          // reverse order of connections in SVG element\n          var temp = SVGEdgeElement.getAttribute('CA-connection').split(',');\n          SVGEdgeElement.setAttribute('CA-connection', temp[1] + ',' + temp[0]);\n          // reverse order of connections in JS object\n          edgeContainer[edgeContainer.indexOf(edge)].connection.reverse();\n        }\n      };\n      if (!arrowIDsWithReverseListener.includes(edge.id)) {\n        SVGArrowElement.addEventListener('click', reverseListener);\n        arrowIDsWithReverseListener.push(edge.id);\n      }\n    });\n  }\n});\nweightBtn.addEventListener('click', function () {\n  if (isWeighted) {\n    _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current = _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.WEIGHT;\n    setButtonColor(weightBtn);\n    document.querySelector('#weight-div').style.visibility = 'visible';\n    var table = document.querySelector('#weight-table');\n    table.append.apply(table, _toConsumableArray(_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getWeightSpans()));\n    getEdgeContainer().forEach(function (edge) {\n      if (edge.helper.hasWeightItem === true) {\n        table.append.apply(table, _toConsumableArray(_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getWeightInputs(edge.id, edge.weight)));\n        return;\n      }\n      var weightItem, weightText;\n      var isLine = edge.type === _models_EdgeModel_js__WEBPACK_IMPORTED_MODULE_1__.Type.UNDIRECTED_LINE || edge.type === _models_EdgeModel_js__WEBPACK_IMPORTED_MODULE_1__.Type.DIRECTED_LINE;\n      weightText = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.addWeightText(edge.id, 0, isLine);\n      canvas.append(weightText);\n      weightItem = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.addWeightItem(edge.id, weightText, _models_EdgeModel_js__WEBPACK_IMPORTED_MODULE_1__.Edge.edgeSVG.stroke, isLine);\n      if (isDirected) {\n        _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.moveArrowForWeight(edge.id, _models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.getArrowBody(SCALE_ARROW));\n      }\n      // text has to be appended first because getComputedTextLength() doesn't work if an element\n      // isn't appended to the canvas, then we have to remove text and append it after item,\n      // so it won't be hidden behind item\n      weightText.remove();\n      canvas.append(weightItem, weightText);\n      table.append.apply(table, _toConsumableArray(_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getWeightInputs(edge.id)));\n      edge.helper.hasWeightItem = true;\n    });\n  }\n});\n// set toolActive.a to undefined when cancel button is clicked\ncancelWeightBtn.addEventListener('click', function () {\n  _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current = _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.UNDEFINED;\n  getEdgeContainer().forEach(function (edge) {\n    return edge.helper.hasWeightItem = false;\n  });\n  _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.removeWeights(getEdgeContainer().map(function (edge) {\n    return edge.id;\n  }));\n});\nsaveWeightBtn.addEventListener('click', function () {\n  weightSaved = true;\n  var weightMap = _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getWeightData(getEdgeContainer().map(function (edge) {\n    return edge.id;\n  }));\n  // update edge attributes\n  edgeContainer.forEach(function (edge) {\n    if (weightMap.has(edge.id)) {\n      edge.weight = weightMap.get(edge.id);\n      edge.isWeighted = true;\n    }\n  });\n  _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.setWeightData(weightMap);\n\n  // this command has to be the last one, otherwise getWeightData won't work\n  _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current = _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.UNDEFINED;\n});\nvar shrunk = false;\nvar originalLookMap = new Map();\nshrinkBtn.addEventListener('click', function () {\n  if (!shrunk) {\n    _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current = _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.SHRINK;\n    setButtonColor(shrinkBtn);\n    // disable deleting operation when toolActive.a = Tool.SHRINK\n    deleteBtn.style.pointerEvents = 'none';\n    shrunk = true;\n    originalLookMap.clear();\n    // hide text and shrink vertex\n    _helpers_shrink_js__WEBPACK_IMPORTED_MODULE_8__.ShrinkManager.getInstance().open(getVertexContainer(), originalLookMap);\n  }\n});\nexpandBtn.addEventListener('click', function () {\n  if (shrunk) {\n    _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current = _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.EXPAND;\n    setButtonColor(expandBtn);\n    // enable deleting operation when toolActive.a = Tool.EXPAND\n    deleteBtn.style.pointerEvents = 'initial';\n    shrunk = false;\n    // show text and expand vertex\n    _helpers_shrink_js__WEBPACK_IMPORTED_MODULE_8__.ShrinkManager.getInstance().close();\n    // go back to normal state (before shrink + expand)\n    _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current = _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.UNDEFINED;\n  }\n});\nscreenshotBtn.addEventListener('click', function () {\n  _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current = _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.SCREENSHOT;\n  setButtonColor(screenshotBtn);\n  _models_ScreenshotModel_js__WEBPACK_IMPORTED_MODULE_11__.ScreenshotManager.getInstance().takeScreenshot().then(function () {\n    _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current = _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.UNDEFINED;\n  });\n});\nsketchBtn.addEventListener('click', function () {\n  _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current = _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.SKETCH;\n  setButtonColor(sketchBtn);\n  var toggle = (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.toggleButtonsExcept)(buttons, []);\n  toggle.activate();\n  var onExit = function onExit() {\n    _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current = _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.UNDEFINED;\n    toggle.deactivate();\n  };\n  _helpers_sketch_js__WEBPACK_IMPORTED_MODULE_10__.SketchManager.getInstance().init(onExit);\n});\ncolorBtn.addEventListener('click', function () {\n  _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current = _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.COLOR;\n  setButtonColor(colorBtn);\n  var toggle = (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.toggleButtonsExcept)(buttons, []);\n  toggle.activate();\n  var onExit = function onExit() {\n    _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current = _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.UNDEFINED;\n    toggle.deactivate();\n  };\n  _helpers_color_js__WEBPACK_IMPORTED_MODULE_9__.ColorManager.getInstance().setVertexContainer(getVertexContainer());\n  _helpers_color_js__WEBPACK_IMPORTED_MODULE_9__.ColorManager.getInstance().init(onExit);\n});\nconfirmExportBtn.addEventListener('click', function () {\n  _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current = _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.UNDEFINED;\n  var str = '';\n  Array.from(canvas.childNodes).forEach(function (el) {\n    // prevent saving canvas configuration\n    if (el.nodeType !== Node.TEXT_NODE && el.className.baseVal !== 'canvas-config') {\n      str += el.outerHTML;\n    }\n    // console.log(el.outerHTML);\n  });\n\n  var obj = {\n    svg: str,\n    isDirected: isDirected,\n    isWeighted: isWeighted,\n    weightSaved: weightSaved,\n    arrowIDsWithReverseListener: arrowIDsWithReverseListener,\n    keysToRemove: keysToRemove,\n    vertexContainer: getVertexContainer(),\n    edgeContainer: getEdgeContainer(),\n    vertexSVG: _.omit(_models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.Vertex.vertexSVG, ['id', 'cx', 'cy', 'x', 'y', 'points']),\n    edgeSVG: _models_EdgeModel_js__WEBPACK_IMPORTED_MODULE_1__.Edge.edgeSVG,\n    IDCounters: _models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.getIDCounters()\n  };\n  obj = JSON.stringify(obj, _models_JSONExtensionModel_js__WEBPACK_IMPORTED_MODULE_6__.replacer);\n  var data = 'text/json;charset=utf-8,' + encodeURIComponent(obj);\n  var link = document.querySelector('#export-link');\n  var fileName = document.querySelector('#export-file-name').value;\n  link.setAttribute('href', 'data:' + data);\n  link.setAttribute('download', fileName + '.json');\n});\nvar imported = document.querySelector('#imported');\nvar importProcedure = function importProcedure() {\n  if (imported !== null) {\n    var parsed = JSON.parse(imported.innerHTML, _models_JSONExtensionModel_js__WEBPACK_IMPORTED_MODULE_6__.reviver);\n    console.log(parsed);\n\n    // append reconstructed elements to the canvas\n    canvas.append.apply(canvas, _toConsumableArray(_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.recon(parsed.svg)));\n    // update containers and set listeners\n    isDirected = parsed.isDirected;\n    isWeighted = parsed.isWeighted;\n    weightSaved = parsed.weightSaved;\n    _models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.Vertex.vertexSVG = parsed.vertexSVG;\n    _models_EdgeModel_js__WEBPACK_IMPORTED_MODULE_1__.Edge.edgeSVG = parsed.edgeSVG;\n    vertexContainer = parsed.vertexContainer;\n    edgeContainer = parsed.edgeContainer;\n    arrowIDsWithReverseListener = parsed.arrowIDsWithReverseListener;\n    keysToRemove = parsed.keysToRemove;\n    _models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.setIDCounters(parsed.IDCounters);\n    var tempV = [],\n      tempE = [];\n    vertexContainer.forEach(function (vertex) {\n      var obj = new _models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.Vertex();\n      Object.assign(obj, vertex);\n      vertex.helper.hasDeleteListener = false;\n      tempV.push(obj);\n    });\n    edgeContainer.forEach(function (edge) {\n      var obj = new _models_EdgeModel_js__WEBPACK_IMPORTED_MODULE_1__.Edge();\n      Object.assign(obj, edge);\n      edge.helper.hasDeleteListener = false;\n      tempE.push(obj);\n    });\n    // all vertices and edges in both containers have object type 'object', so we won't be able\n    // to access methods from the Vertex and Edge class without creating new instances\n    // shallow copy is being used\n    vertexContainer = _.clone(tempV);\n    edgeContainer = _.clone(tempE);\n    connector.v1 = connector.v2 = undefined;\n    vertexContainer.forEach(function (vertex) {\n      _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_5__.getVertexFromID(vertex.id).addEventListener('click', function (event) {\n        if (_models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current !== _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.DRAW_EDGE) return;\n        drawEdgeListener(event, vertex);\n        // map.set(vertex, event);  // not needed line!\n      });\n\n      map.set(vertex, undefined);\n    });\n    // refresh graph types\n    isDirected ? graphType1.value = 'directed' : graphType1.value = 'undirected';\n    isWeighted ? graphType2.value = 'weighted' : graphType2.value = 'unweighted';\n  }\n};\nif (imported.innerHTML.trim().length > 0) {\n  // wait for canvas config to load to avoid placing grid over graph\n  setTimeout(function () {\n    return importProcedure();\n  }, 400);\n}\n\n// pass containers to the Algorithm Model\ndocument.querySelector('#algorithm').addEventListener('click', function () {\n  _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current = _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.UNDEFINED;\n  _models_AlgorithmModel_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].passContainers({\n    vertexContainer: getVertexContainer(),\n    edgeContainer: getEdgeContainer()\n  });\n});\nvar clearCanvas = function clearCanvas() {\n  // update vertex container\n  getVertexContainer();\n  // remove everything except the canvas configuration elements\n  var nodes = Array.from(canvas.childNodes);\n  nodes = nodes.filter(function (childNode) {\n    return !childNode.classList.value.includes('canvas-config');\n  });\n  nodes.forEach(function (childNode) {\n    return childNode.remove();\n  });\n\n  // todo new - make SEPARATE CONTAINER FOR ALL THESE STRUCTURES\n  (0,_models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.addToVertexIDCounter)(vertexContainer.length * -1);\n  (0,_models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.addToEdgeIDCounter)(edgeContainer.length * -1);\n  vertexContainer = [];\n  edgeContainer = [];\n  connector = {\n    v1: undefined,\n    v2: undefined\n  };\n  map.clear();\n  keysToRemove.clear();\n  map2.clear();\n  arrowIDsWithReverseListener = [];\n  shrunk = false;\n  originalLookMap.clear();\n  _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.toolActive.current = _models_ToolEnumModel_js__WEBPACK_IMPORTED_MODULE_4__.Tool.UNDEFINED;\n};\n\n//# sourceURL=webpack://test_zav/./public/scripts/drawing.js?");

/***/ }),

/***/ "./public/scripts/helpers/color.js":
/*!*****************************************!*\
  !*** ./public/scripts/helpers/color.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ColorManager\": () => (/* binding */ ColorManager)\n/* harmony export */ });\n/* harmony import */ var _models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/VertexModel.js */ \"./public/scripts/models/VertexModel.js\");\n/* harmony import */ var _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../models/DrawingHelperModel.js */ \"./public/scripts/models/DrawingHelperModel.js\");\n/* harmony import */ var _models_ClientDefaultsModel_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../models/ClientDefaultsModel.js */ \"./public/scripts/models/ClientDefaultsModel.js\");\n/* harmony import */ var _models_EdgeModel_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../models/EdgeModel.js */ \"./public/scripts/models/EdgeModel.js\");\n/* harmony import */ var _utils_traversal_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/traversal.js */ \"./public/scripts/utils/traversal.js\");\n/* harmony import */ var _models_FaceTrackerModel_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../models/FaceTrackerModel.js */ \"./public/scripts/models/FaceTrackerModel.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\n\n\n\nvar ColorManager = /*#__PURE__*/function () {\n  function ColorManager() {\n    _classCallCheck(this, ColorManager);\n    _defineProperty(this, \"tool\", void 0);\n    _defineProperty(this, \"initialized\", false);\n    _defineProperty(this, \"save\", false);\n    _defineProperty(this, \"onModeCloses\", []);\n    _defineProperty(this, \"onToolCloses\", []);\n  }\n  _createClass(ColorManager, [{\n    key: \"init\",\n    value: function init(onExit) {\n      var _this = this;\n      var brush = document.querySelector('#color-tool-brush');\n      var eraser = document.querySelector('#color-tool-eraser');\n      var colorToolbar = document.querySelector('#color-toolbar');\n      var select = document.querySelector('#color-toolbar-select');\n      var exitBtn = document.querySelector('#color-tool-exit');\n      var saveColorCheckbox = document.querySelector('#save-color-state');\n      var faceColoring = document.querySelector('#face-coloring-option');\n      this.palette = document.querySelector('#color-toolbar-color-palette');\n      faceColoring.disabled = !((0,_utils_traversal_js__WEBPACK_IMPORTED_MODULE_4__.isSimpleGraph)() && (0,_utils_traversal_js__WEBPACK_IMPORTED_MODULE_4__.isConnectedGraph)(this.vertexContainer));\n      if (this.initialized) {\n        setVisible(colorToolbar);\n        select.selectedIndex = 0; // default to vertex coloring\n        this.updateColorMode(select.value);\n        return;\n      }\n      setVisible(colorToolbar);\n      exitBtn.addEventListener('click', function () {\n        _this.runModeCloses();\n        _this.runToolCloses();\n        setInvisible(colorToolbar);\n        ColorUtil.removeEdgeWrappers();\n        onExit();\n      });\n      saveColorCheckbox.addEventListener('change', function () {\n        _this.save = saveColorCheckbox.checked;\n      });\n      this.initialized = true;\n      this.save = saveColorCheckbox.checked;\n      this.onModeCloses = [];\n      this.onToolCloses = [];\n      brush.addEventListener('click', function () {\n        _this.tool = 'brush';\n        _this.runToolCloses();\n        _this.updateColorMode(select.value);\n        brush.style.border = '1px solid white';\n        eraser.style.border = 'none';\n        EraseUtil.disableErase();\n      });\n      eraser.addEventListener('click', function () {\n        _this.tool = 'eraser';\n        _this.runToolCloses();\n        eraser.style.border = '1px solid white';\n        brush.style.border = 'none';\n        EraseUtil.enableErase();\n      });\n      select.addEventListener('change', function (e) {\n        _this.runModeCloses();\n        if (_this.tool === 'brush') {\n          _this.updateColorMode(e.target.value);\n        }\n      });\n      _models_FaceTrackerModel_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].init();\n    }\n  }, {\n    key: \"updateColorMode\",\n    value: function updateColorMode(coloring) {\n      if (coloring === 'vertex') {\n        this.updateCallbacks(ColorUtil.colorVertices);\n      } else if (coloring === 'edge') {\n        this.updateCallbacks(ColorUtil.colorEdges);\n      } else {\n        this.updateCallbacks(ColorUtil.colorFaces);\n      }\n    }\n  }, {\n    key: \"updateCallbacks\",\n    value: function updateCallbacks(colorMethod) {\n      var _this$onToolCloses;\n      var callbacks = colorMethod(this.palette);\n      this.onModeCloses = callbacks.onModeCloses;\n      this.onToolCloses = (_this$onToolCloses = this.onToolCloses).concat.apply(_this$onToolCloses, _toConsumableArray(callbacks.onToolCloses));\n    }\n  }, {\n    key: \"isSaveActive\",\n    value: function isSaveActive() {\n      return this.save;\n    }\n  }, {\n    key: \"setVertexContainer\",\n    value: function setVertexContainer(vertexContainer) {\n      this.vertexContainer = vertexContainer;\n    }\n  }, {\n    key: \"getVertexContainer\",\n    value: function getVertexContainer() {\n      return this.vertexContainer;\n    }\n  }, {\n    key: \"runModeCloses\",\n    value: function runModeCloses() {\n      if (this.onModeCloses !== undefined) {\n        this.onModeCloses.forEach(function (cb) {\n          return cb();\n        });\n      }\n    }\n  }, {\n    key: \"runToolCloses\",\n    value: function runToolCloses() {\n      if (this.onToolCloses !== undefined) {\n        this.onToolCloses.forEach(function (cb) {\n          return cb();\n        });\n      }\n    }\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance() {\n      return ColorManager.instance;\n    }\n  }]);\n  return ColorManager;\n}();\n_defineProperty(ColorManager, \"instance\", new ColorManager());\nvar ColorUtil = /*#__PURE__*/function () {\n  function ColorUtil() {\n    _classCallCheck(this, ColorUtil);\n  }\n  _createClass(ColorUtil, null, [{\n    key: \"colorVertices\",\n    value: function colorVertices(palette) {\n      var vertices = (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.getAllVertices)();\n      var onModeCloses = [];\n      var onToolCloses = [];\n      vertices.forEach(function (v) {\n        var cbs = ColorUtil.colorVertex(v, palette);\n        onModeCloses.push(cbs.onModeClose);\n        onToolCloses.push(cbs.onToolClose);\n      });\n      return {\n        onModeCloses: onModeCloses,\n        onToolCloses: onToolCloses\n      };\n    }\n  }, {\n    key: \"colorEdges\",\n    value: function colorEdges(palette) {\n      var edges = (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.getAllEdges)();\n      var onModeCloses = [];\n      var onToolCloses = [];\n      edges.forEach(function (e) {\n        ColorUtil.addEdgeWrapper(e);\n        var cbs = ColorUtil.colorEdge(e, palette);\n        onModeCloses.push(cbs.onModeClose);\n        onToolCloses.push(cbs.onToolClose);\n      });\n      return {\n        onModeCloses: onModeCloses,\n        onToolCloses: onToolCloses\n      };\n    }\n  }, {\n    key: \"colorFaces\",\n    value: function colorFaces(palette) {\n      var onModeCloses = [];\n      var onToolCloses = [];\n      var onClick = function onClick(e) {\n        if (e.target.tagName !== 'svg') {\n          return;\n        }\n        var bounds = SVG_CANVAS.getBoundingClientRect();\n        var x = e.clientX - bounds.x;\n        var y = e.clientY - bounds.y;\n        var closestEdge = null;\n        var min = Number.MAX_VALUE;\n        (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.getAllEdges)().forEach(function (edge) {\n          // getting points from the line only because the arcs\n          // and the loops aren't present in a simple graph\n          var points = (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.getPointsFromLine)(edge);\n          var x1 = points[0];\n          var y1 = points[1];\n          var x2 = x1 + points[2];\n          var y2 = y1 + points[3];\n          var d = (0,_utils_traversal_js__WEBPACK_IMPORTED_MODULE_4__.distanceFromLine)(x1, y1, x2, y2, x, y);\n          if (d < min) {\n            min = d;\n            closestEdge = edge;\n          }\n        });\n        var v0 = ColorManager.getInstance().getVertexContainer().find(function (v) {\n          return v.id === (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.getConnection)(closestEdge)[0];\n        });\n        var cycles = (0,_utils_traversal_js__WEBPACK_IMPORTED_MODULE_4__.fundamentalCycleSet)(ColorManager.getInstance().getVertexContainer(), v0);\n        // console.log(structuredClone(cycles));\n\n        var cycle = null;\n        var finalPolygon = null;\n        var minArea = Number.MAX_VALUE;\n        for (var i = cycles.length - 1; i >= 0; i--) {\n          var polygon = [];\n          var _iterator = _createForOfIteratorHelper(cycles[i]),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var id = _step.value;\n              var center = (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.getCenter)((0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.getVertexFromID)(id));\n              polygon.push([center.x, center.y]);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          if ((0,_utils_traversal_js__WEBPACK_IMPORTED_MODULE_4__.rayCasting)(polygon, x, y)) {\n            var area = (0,_utils_traversal_js__WEBPACK_IMPORTED_MODULE_4__.shoelace)(polygon);\n            // console.log(\"area: \", area, \" cycle: \", cycles[i]);\n            if (area < minArea) {\n              minArea = area;\n              cycle = cycles[i];\n              finalPolygon = polygon;\n            }\n          }\n        }\n        if (cycle !== null) {\n          var face = (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.createFace)(finalPolygon, cycle, palette.getAttribute('color'));\n          SVG_CANVAS.appendChild(face);\n          (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.restoreAll)();\n        }\n      };\n      SVG_CANVAS.addEventListener('click', onClick);\n      var onClose = function onClose() {\n        SVG_CANVAS.removeEventListener('click', onClick);\n        if (!ColorManager.getInstance().isSaveActive()) {\n          var faces = (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.getAll)('polygon.face');\n          if (faces !== null) {\n            faces.forEach(function (face) {\n              return SVG_CANVAS.removeChild(face);\n            });\n          }\n        }\n      };\n      onModeCloses.push(onClose);\n      onToolCloses.push(onClose);\n      return {\n        onModeCloses: onModeCloses,\n        onToolCloses: onToolCloses\n      };\n    }\n  }, {\n    key: \"colorVertex\",\n    value: function colorVertex(vertex, palette) {\n      var defaultColor = _models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.Vertex.vertexSVG.fill;\n      var enter = function enter() {};\n      var leave = function leave() {};\n      var click = function click() {\n        vertex.setAttribute('fill', palette.getAttribute('color'));\n      };\n      var listeners = {\n        enter: enter,\n        leave: leave,\n        click: click\n      };\n      ColorUtil.addColorListeners(vertex, listeners);\n      var onModeClose = function onModeClose() {\n        if (!ColorManager.getInstance().isSaveActive()) {\n          vertex.setAttribute('fill', defaultColor);\n        }\n        ColorUtil.removeColorListeners(vertex, listeners);\n      };\n      var onToolClose = function onToolClose() {\n        ColorUtil.removeColorListeners(vertex, listeners);\n      };\n      return {\n        onModeClose: onModeClose,\n        onToolClose: onToolClose\n      };\n    }\n  }, {\n    key: \"colorEdge\",\n    value: function colorEdge(edge, palette) {\n      var id = (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.getIDFromEdge)(edge);\n      var arrow = (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.getArrowFromID)(id);\n      var weightItem = (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.getWeightItemFromID)(id);\n      var defaultColor = _models_EdgeModel_js__WEBPACK_IMPORTED_MODULE_3__.Edge.edgeSVG.stroke;\n      var defaultWidth = edge.getAttribute('stroke-width');\n      var prevColor = defaultColor;\n      var enter = function enter() {\n        var color = palette.getAttribute('color');\n        if (prevColor === color) {\n          return;\n        }\n        edge.setAttribute('stroke', color);\n        edge.setAttribute('stroke-width', '10');\n        edge.setAttribute('stroke-dasharray', '5,2.5');\n      };\n      var leave = function leave() {\n        if (prevColor === palette.getAttribute('color')) {\n          return;\n        }\n        edge.setAttribute('stroke', prevColor);\n        edge.setAttribute('stroke-width', defaultWidth);\n        edge.removeAttribute('stroke-dasharray');\n      };\n      var click = function click() {\n        var color = palette.getAttribute('color');\n        prevColor = edge.getAttribute('stroke');\n        edge.removeAttribute('stroke-dasharray');\n        edge.setAttribute('stroke', color);\n        edge.setAttribute('stroke-width', defaultWidth);\n        if (arrow !== null) {\n          arrow.setAttribute('fill', color);\n        }\n        if (weightItem !== null) {\n          weightItem.setAttribute('fill', color);\n        }\n      };\n      var listeners = {\n        enter: enter,\n        leave: leave,\n        click: click\n      };\n      var onModeClose = function onModeClose() {\n        if (!ColorManager.getInstance().isSaveActive()) {\n          edge.setAttribute('stroke', defaultColor);\n          edge.setAttribute('stroke-width', defaultWidth);\n          if (arrow !== null) {\n            arrow.setAttribute('fill', defaultColor);\n          }\n          if (weightItem !== null) {\n            weightItem.setAttribute('fill', defaultColor);\n          }\n        }\n        ColorUtil.removeColorListeners(edge, listeners);\n        ColorUtil.removeEdgeWrappers();\n      };\n      var onToolClose = function onToolClose() {\n        if (arrow !== null) {\n          arrow.setAttribute('fill', defaultColor);\n        }\n        if (weightItem !== null) {\n          weightItem.setAttribute('fill', defaultColor);\n        }\n        ColorUtil.removeColorListeners(edge, listeners);\n        ColorUtil.removeEdgeWrappers();\n      };\n      ColorUtil.addColorListeners(edge, listeners);\n      return {\n        onModeClose: onModeClose,\n        onToolClose: onToolClose\n      };\n    }\n  }, {\n    key: \"addColorListeners\",\n    value: function addColorListeners(el, listeners) {\n      el.addEventListener('mouseenter', listeners.enter);\n      el.addEventListener('mouseleave', listeners.leave);\n      el.addEventListener('click', listeners.click);\n    }\n  }, {\n    key: \"removeColorListeners\",\n    value: function removeColorListeners(el, listeners) {\n      el.removeEventListener('mouseenter', listeners.enter);\n      el.removeEventListener('mouseleave', listeners.leave);\n      el.removeEventListener('click', listeners.click);\n    }\n  }, {\n    key: \"addEdgeWrapper\",\n    value: function addEdgeWrapper(edge) {\n      var overlay = edge.cloneNode(false);\n      overlay.setAttribute('id', 'color-' + edge.getAttribute('id'));\n      overlay.setAttribute('stroke-width', '10');\n      overlay.style.strokeOpacity = '0';\n      overlay.onmouseenter = function () {\n        return edge.dispatchEvent(new MouseEvent('mouseenter', _models_ClientDefaultsModel_js__WEBPACK_IMPORTED_MODULE_2__.clickOptions));\n      };\n      overlay.onmouseleave = function () {\n        return edge.dispatchEvent(new MouseEvent('mouseleave', _models_ClientDefaultsModel_js__WEBPACK_IMPORTED_MODULE_2__.clickOptions));\n      };\n      overlay.onclick = function () {\n        return edge.dispatchEvent(new MouseEvent('click', _models_ClientDefaultsModel_js__WEBPACK_IMPORTED_MODULE_2__.clickOptions));\n      };\n      SVG_CANVAS.append(overlay);\n      var con = edge.getAttribute('CA-connection').split(',').map(function (el) {\n        return parseInt(el);\n      });\n      (0,_models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.restore)((0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.getVertexFromID)(con[0]), (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.getVertexFromID)(con[1]), (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.getTextFromID)(con[0]), (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.getTextFromID)(con[1]));\n    }\n  }, {\n    key: \"removeEdgeWrappers\",\n    value: function removeEdgeWrappers() {\n      (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.getAll)('[id^=\"color-edge-id-\"]').forEach(function (el) {\n        return el.remove();\n      });\n    }\n  }]);\n  return ColorUtil;\n}();\nvar EraseUtil = /*#__PURE__*/function () {\n  function EraseUtil() {\n    _classCallCheck(this, EraseUtil);\n  }\n  _createClass(EraseUtil, null, [{\n    key: \"enableErase\",\n    value: function enableErase() {\n      var vertices = (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.getAllVertices)();\n      var edges = (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.getAllEdges)();\n      var faces = (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.getAll)('polygon.face');\n      if (vertices !== null) {\n        vertices.forEach(function (v) {\n          return EraseUtil.eraseMap.set(v, function () {\n            return v.setAttribute('fill', _models_VertexModel_js__WEBPACK_IMPORTED_MODULE_0__.Vertex.vertexSVG.fill);\n          });\n        });\n      }\n      if (edges !== null) {\n        edges.forEach(function (e) {\n          return EraseUtil.eraseMap.set(e, function () {\n            return e.setAttribute('stroke', _models_EdgeModel_js__WEBPACK_IMPORTED_MODULE_3__.Edge.edgeSVG.stroke);\n          });\n        });\n      }\n      if (faces !== null) {\n        faces.forEach(function (f) {\n          return EraseUtil.eraseMap.set(f, function () {\n            return SVG_CANVAS.removeChild(f);\n          });\n        });\n      }\n      EraseUtil.eraseMap.forEach(function (val, key) {\n        return key.addEventListener('click', val);\n      });\n    }\n  }, {\n    key: \"disableErase\",\n    value: function disableErase() {\n      EraseUtil.eraseMap.forEach(function (val, key) {\n        return key.removeEventListener('click', val);\n      });\n    }\n  }]);\n  return EraseUtil;\n}();\n_defineProperty(EraseUtil, \"eraseMap\", new Map());\n\n\n//# sourceURL=webpack://test_zav/./public/scripts/helpers/color.js?");

/***/ }),

/***/ "./public/scripts/helpers/shrink.js":
/*!******************************************!*\
  !*** ./public/scripts/helpers/shrink.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShrinkManager\": () => (/* binding */ ShrinkManager)\n/* harmony export */ });\n/* harmony import */ var _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/DrawingHelperModel.js */ \"./public/scripts/models/DrawingHelperModel.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nvar ShrinkManager = /*#__PURE__*/function () {\n  function ShrinkManager() {\n    _classCallCheck(this, ShrinkManager);\n    _defineProperty(this, \"div\", void 0);\n    _defineProperty(this, \"input\", void 0);\n    _defineProperty(this, \"vertexContainer\", void 0);\n    _defineProperty(this, \"originalLookMap\", void 0);\n    _defineProperty(this, \"listener\", void 0);\n    _defineProperty(this, \"shrinkValue\", 5);\n  }\n  _createClass(ShrinkManager, [{\n    key: \"open\",\n    value: function open(vertexContainer, originalLookMap) {\n      var _this = this;\n      this.originalLookMap = originalLookMap;\n      vertexContainer.forEach(function (v) {\n        return originalLookMap.set(v, _this.shrink(v));\n      });\n      this.div = document.querySelector('#shrink-div');\n      setVisible(this.div);\n      this.input = document.querySelector('#shrink-input');\n      this.input.setAttribute('value', this.shrinkValue.toString());\n      this.listener = function (e) {\n        var value = parseFloat(e.target.value);\n        document.querySelector('#shrink-val').innerHTML = value.toFixed(1);\n        _this.shrinkValue = value;\n        vertexContainer.forEach(function (v) {\n          return _this.shrink(v);\n        });\n      };\n      this.input.addEventListener('input', this.listener);\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      setInvisible(this.div);\n      _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_0__.expand(this.originalLookMap);\n      this.input.removeEventListener('input', this.listener);\n    }\n  }, {\n    key: \"shrink\",\n    value: function shrink(vertexObj) {\n      return _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_0__.shrink(vertexObj, this.shrinkValue);\n    }\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance() {\n      return ShrinkManager.instance;\n    }\n  }]);\n  return ShrinkManager;\n}();\n_defineProperty(ShrinkManager, \"instance\", new ShrinkManager());\n\n\n//# sourceURL=webpack://test_zav/./public/scripts/helpers/shrink.js?");

/***/ }),

/***/ "./public/scripts/helpers/sketch.js":
/*!******************************************!*\
  !*** ./public/scripts/helpers/sketch.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SketchManager\": () => (/* binding */ SketchManager)\n/* harmony export */ });\n/* harmony import */ var _models_DrawingHelperModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/DrawingHelperModel */ \"./public/scripts/models/DrawingHelperModel.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n// line drawing source: https://javascript.plainenglish.io/\n// how-to-draw-a-smooth-curve-through-n-points-using-javascript-html5-canvas-86ecb84b6d6d\n\n\nvar TOOL_BORDER = '1px solid white';\nvar TEXT_BORDER_WIDTH = 2;\nvar TEXT_SVG_CLASS = 'sketch-text';\nvar MODES = ['pencil', 'pen', 'brush'];\nvar PENCIL_STROKE_COLOR = '#4d4d4d';\nvar PENCIL_SHADOW_COLOR = 'rgba(0, 0, 0, 0)';\nvar SketchManager = /*#__PURE__*/function () {\n  function SketchManager() {\n    _classCallCheck(this, SketchManager);\n    _defineProperty(this, \"canvas\", void 0);\n    _defineProperty(this, \"tool\", void 0);\n    _defineProperty(this, \"fontSize\", void 0);\n    _defineProperty(this, \"drawListeners\", void 0);\n    _defineProperty(this, \"eraseListeners\", void 0);\n    _defineProperty(this, \"textEraseListeners\", new Map());\n    this.canvas = initSketch();\n    this.tool = 'none';\n    this.fontSize = '16px';\n  }\n  _createClass(SketchManager, [{\n    key: \"init\",\n    value: function init(onExit) {\n      if (SketchManager.initialized === true) {\n        return;\n      }\n      var exitBtn = document.querySelector('#sketch-tool-exit');\n      exitBtn.addEventListener('click', function () {\n        return onExit();\n      });\n      SketchManager.initialized = true;\n    }\n  }, {\n    key: \"handleToolChange\",\n    value: function handleToolChange() {\n      if (this.tool === 'draw') this.drawExit();else if (this.tool === 'erase') this.eraseExit();\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(mode) {\n      this.handleToolChange();\n      this.tool = 'draw';\n      if (!MODES.includes(mode)) {\n        throw Error('Invalid tool in draw!');\n      }\n      var bounds = this.canvas.getBoundingClientRect();\n      var offsetX = bounds.left;\n      var offsetY = bounds.top;\n      var context = this.canvas.getContext('2d');\n      context.lineCap = 'round';\n      context.lineJoin = 'round';\n      context.imageSmoothingEnabled = true;\n      context.globalCompositeOperation = 'source-over';\n      var drawingActive = false;\n      var palette = document.querySelector('#sketch-toolbar-color-palette');\n      var thickness = parseInt(document.querySelector('#thickness-value').innerHTML.split('px')[0]);\n      var mousedown = function mousedown(e) {\n        if (mode === 'pencil') {\n          context.strokeStyle = PENCIL_STROKE_COLOR;\n          context.lineWidth = thickness;\n          context.shadowColor = PENCIL_SHADOW_COLOR;\n          context.shadowBlur = 0;\n        } else {\n          context.strokeStyle = palette.getAttribute('color');\n          if (mode === 'brush') {\n            context.shadowColor = palette.getAttribute('color');\n            context.shadowBlur = 0.2 * thickness;\n            context.lineWidth = thickness - 2 * context.shadowBlur;\n          } else if (mode === 'pen') {\n            context.lineWidth = thickness;\n          }\n        }\n        drawingActive = true;\n        context.moveTo(e.clientX - offsetX, e.clientY - offsetY);\n      };\n      var mousemove = function mousemove(e) {\n        if (!drawingActive) {\n          return;\n        }\n        context.lineTo(e.clientX - offsetX, e.clientY - offsetY);\n        context.stroke();\n      };\n      var mouseup = function mouseup() {\n        drawingActive = false;\n        context.beginPath();\n      };\n      this.canvas.addEventListener('mousedown', mousedown);\n      this.canvas.addEventListener('mousemove', mousemove);\n      this.canvas.addEventListener('mouseup', mouseup);\n      this.drawListeners = {\n        mousedown: mousedown,\n        mousemove: mousemove,\n        mouseup: mouseup\n      };\n    }\n  }, {\n    key: \"drawExit\",\n    value: function drawExit() {\n      this.canvas.removeEventListener('mousedown', this.drawListeners.mousedown);\n      this.canvas.removeEventListener('mousemove', this.drawListeners.mousemove);\n      this.canvas.removeEventListener('mouseup', this.drawListeners.mouseup);\n      this.drawListeners = null;\n    }\n  }, {\n    key: \"erase\",\n    value: function erase() {\n      this.handleToolChange();\n      this.tool = 'erase';\n      var bounds = this.canvas.getBoundingClientRect();\n      var offsetX = bounds.left;\n      var offsetY = bounds.top;\n      var context = this.canvas.getContext('2d');\n      context.lineCap = 'round';\n      context.lineJoin = 'round';\n      context.imageSmoothingEnabled = true;\n      context.globalCompositeOperation = 'destination-out';\n      var erasingActive = false;\n      var mousedown = function mousedown(e) {\n        context.lineWidth = parseInt(document.querySelector('#thickness-value').innerHTML.split('px')[0]);\n        erasingActive = true;\n        context.moveTo(e.clientX - offsetX, e.clientY - offsetY);\n      };\n      var mousemove = function mousemove(e) {\n        if (!erasingActive) {\n          return;\n        }\n        context.lineTo(e.clientX - offsetX, e.clientY - offsetY);\n        context.stroke();\n      };\n      var mouseup = function mouseup() {\n        erasingActive = false;\n        context.beginPath();\n      };\n      this.canvas.addEventListener('mousedown', mousedown);\n      this.canvas.addEventListener('mousemove', mousemove);\n      this.canvas.addEventListener('mouseup', mouseup);\n      this.eraseListeners = {\n        mousedown: mousedown,\n        mousemove: mousemove,\n        mouseup: mouseup\n      };\n      this.addTextEraseListeners();\n    }\n  }, {\n    key: \"eraseExit\",\n    value: function eraseExit() {\n      this.canvas.removeEventListener('mousedown', this.eraseListeners.mousedown);\n      this.canvas.removeEventListener('mousemove', this.eraseListeners.mousemove);\n      this.canvas.removeEventListener('mouseup', this.eraseListeners.mouseup);\n      this.eraseListeners = null;\n      this.removeTextEraseListeners();\n    }\n  }, {\n    key: \"addTextEraseListeners\",\n    value: function addTextEraseListeners() {\n      var _this = this;\n      var texts = (0,_models_DrawingHelperModel__WEBPACK_IMPORTED_MODULE_0__.getAll)('.' + TEXT_SVG_CLASS);\n      if (texts === null) return;\n      texts.forEach(function (text) {\n        if (_this.textEraseListeners.has(text)) {\n          text.addEventListener('click', _this.textEraseListeners.get(text));\n        } else {\n          text.addEventListener('click', function () {\n            SVG_CANVAS.removeChild(text);\n            _this.textEraseListeners[\"delete\"](text);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"removeTextEraseListeners\",\n    value: function removeTextEraseListeners() {\n      this.textEraseListeners.forEach(function (val, key) {\n        return key.removeEventListener('click', val);\n      });\n    }\n  }, {\n    key: \"text\",\n    value: function text() {\n      this.handleToolChange();\n      this.tool = 'text';\n      var palette = document.querySelector('#sketch-toolbar-color-palette');\n      var div = document.createElement('div');\n      div.className = 'sketch-text-div';\n      div.style.border = \"\".concat(TEXT_BORDER_WIDTH, \"px solid midnightblue\");\n      var textArea = document.createElement('textarea');\n      textArea.spellcheck = false;\n      textArea.style.color = palette.getAttribute('color');\n      textArea.style.fontSize = this.fontSize;\n      textArea.style.resize = 'none';\n      textArea.style.overflowWrap = 'normal';\n      textArea.addEventListener('blur', function () {\n        // textArea is unfocused\n        var bounds = textArea.getBoundingClientRect();\n        var textBtn = document.querySelector('#sketch-tool-text');\n        var text = document.createElementNS(SVG_NS_URI, 'text');\n        var x = bounds.left + TEXT_BORDER_WIDTH - SVG_CANVAS_BOUNDS.left;\n        var y = bounds.top + TEXT_BORDER_WIDTH - SVG_CANVAS_BOUNDS.top;\n        text.setAttribute('x', x.toString());\n        text.setAttribute('y', y.toString());\n        text.setAttribute('font-size', textArea.style.fontSize);\n        text.setAttribute('fill', palette.getAttribute('color'));\n        text.setAttribute('class', TEXT_SVG_CLASS);\n        textArea.value.split('\\n').forEach(function (line) {\n          var tspan = document.createElementNS(SVG_NS_URI, 'tspan');\n          tspan.setAttribute('x', text.getAttribute('x'));\n          tspan.setAttribute('dy', '1.2em');\n          tspan.textContent = line;\n          text.appendChild(tspan);\n        });\n        div.remove();\n        SVG_CANVAS.appendChild(text);\n        textBtn.style.border = 'none';\n      });\n      textArea.style.color = palette.getAttribute('color');\n      textArea.addEventListener('keydown', function (e) {\n        if (e.ctrlKey && e.key === '+') {\n          e.preventDefault();\n          var size = parseInt(textArea.style.fontSize.split('px')[0]);\n          if (size < 100) {\n            textArea.style.fontSize = \"\".concat(size + 1, \"px\");\n          }\n        } else if (e.ctrlKey && e.key === '-') {\n          e.preventDefault();\n          var _size = parseInt(textArea.style.fontSize.split('px')[0]);\n          if (_size > 2) {\n            textArea.style.fontSize = \"\".concat(_size - 1, \"px\");\n          }\n        }\n      });\n      var x0, y0;\n      var mousedown = function mousedown(e) {\n        document.body.appendChild(div);\n        document.addEventListener('mousemove', mousemove);\n        div.style.left = \"\".concat(x0 = e.clientX, \"px\");\n        div.style.top = \"\".concat(y0 = e.clientY, \"px\");\n      };\n      var mousemove = function mousemove(e) {\n        if (!isPointWithinSVGCanvas(e.clientX, e.clientY)) {\n          return;\n        }\n        div.style.left = \"\".concat(Math.min(x0, e.clientX), \"px\");\n        div.style.width = \"\".concat(Math.abs(x0 - e.clientX), \"px\");\n        div.style.top = \"\".concat(Math.min(y0, e.clientY), \"px\");\n        div.style.height = \"\".concat(Math.abs(y0 - e.clientY), \"px\");\n      };\n      var mouseup = function mouseup() {\n        document.removeEventListener('mousedown', mousedown);\n        document.removeEventListener('mousemove', mousemove);\n        document.removeEventListener('mouseup', mouseup);\n        div.append(textArea);\n        move(div, textArea);\n        textArea.focus();\n      };\n      document.addEventListener('mousedown', mousedown);\n      document.addEventListener('mouseup', mouseup);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(confirmed) {\n      this.handleToolChange();\n      this.tool = 'reset';\n      if (confirmed) {\n        this.canvas.getContext('2d').reset();\n      }\n    }\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance() {\n      return SketchManager.instance;\n    }\n  }]);\n  return SketchManager;\n}();\n_defineProperty(SketchManager, \"instance\", new SketchManager());\nfunction initSketch() {\n  var sketchToolbar = document.querySelector('#sketch-toolbar');\n  var sketchCanvas = document.createElement('canvas');\n  sketchCanvas.width = SVG_CANVAS_BOUNDS.width;\n  sketchCanvas.height = SVG_CANVAS_BOUNDS.height;\n  sketchCanvas.style.left = SVG_CANVAS_BOUNDS.left.toString().concat('px');\n  sketchCanvas.style.top = SVG_CANVAS_BOUNDS.top.toString().concat('px');\n  sketchCanvas.style.position = 'absolute';\n  sketchCanvas.style.backgroundColor = 'none';\n  setInvisible(sketchCanvas);\n  document.body.appendChild(sketchCanvas);\n\n  // resize drawing sketchCanvas whenever SVG sketchCanvas resizes\n  var resizeObserver = new ResizeObserver(function (entries) {\n    var rect = entries[0].contentRect;\n    sketchCanvas.width = rect.width;\n    sketchCanvas.height = rect.height;\n  });\n  resizeObserver.observe(SVG_CANVAS);\n  var sketchBtn = document.querySelector('#operation-img-10');\n  sketchBtn.addEventListener('click', function () {\n    sketchCanvas.style.zIndex = '5';\n    sketchToolbar.style.zIndex = '10';\n    setVisible(sketchCanvas);\n    setVisible(sketchToolbar);\n  });\n  initSketchTools(sketchCanvas, sketchToolbar);\n  initThickness();\n  initTextErase(sketchCanvas);\n  return sketchCanvas;\n}\nfunction initSketchTools(sketchCanvas, sketchToolbar) {\n  var pencil = document.querySelector('#sketch-tool-pencil');\n  var pen = document.querySelector('#sketch-tool-pen');\n  var brush = document.querySelector('#sketch-tool-brush');\n  var eraser = document.querySelector('#sketch-tool-eraser');\n  var text = document.querySelector('#sketch-tool-text');\n  var reset = document.querySelector('#sketch-tool-reset');\n  var exit = document.querySelector('#sketch-tool-exit');\n  var sketchResetDiv = document.querySelector('#sketch-reset-div');\n  sketchResetDiv.style.zIndex = '10';\n  var clicked = null;\n  var setClickedBorder = function setClickedBorder() {\n    return clicked !== null ? clicked.style.border = 'none' : undefined;\n  };\n  pencil.addEventListener('click', function () {\n    setClickedBorder();\n    pencil.style.border = TOOL_BORDER;\n    clicked = pencil;\n    SketchManager.getInstance().draw('pencil');\n  });\n  pen.addEventListener('click', function () {\n    setClickedBorder();\n    pen.style.border = TOOL_BORDER;\n    clicked = pen;\n    SketchManager.getInstance().draw('pen');\n  });\n  brush.addEventListener('click', function () {\n    setClickedBorder();\n    brush.style.border = TOOL_BORDER;\n    clicked = brush;\n    SketchManager.getInstance().draw('brush');\n  });\n  eraser.addEventListener('click', function () {\n    setClickedBorder();\n    eraser.style.border = TOOL_BORDER;\n    clicked = eraser;\n    SketchManager.getInstance().erase('eraser');\n  });\n  text.addEventListener('click', function () {\n    setClickedBorder();\n    text.style.border = TOOL_BORDER;\n    clicked = text;\n    SketchManager.getInstance().text();\n  });\n  reset.addEventListener('click', function () {\n    setClickedBorder();\n    reset.style.border = TOOL_BORDER;\n    clicked = reset;\n    setVisible(sketchResetDiv);\n  });\n  exit.addEventListener('click', function () {\n    setClickedBorder();\n    clicked = null;\n    setInvisible(sketchToolbar);\n    setInvisible(sketchCanvas);\n  });\n  var confirmSketchReset = document.querySelector('#confirm-sketch-reset-button');\n  var cancelSketchReset = document.querySelector('#cancel-sketch-reset-button');\n  confirmSketchReset.addEventListener('click', function () {\n    clicked !== null ? clicked.style.border = 'none' : undefined;\n    clicked = null;\n    SketchManager.getInstance().reset(true);\n    setInvisible(sketchResetDiv);\n  });\n  cancelSketchReset.addEventListener('click', function () {\n    clicked !== null ? clicked.style.border = 'none' : undefined;\n    clicked = null;\n    SketchManager.getInstance().reset(false);\n    setInvisible(sketchResetDiv);\n  });\n}\nfunction initThickness() {\n  var plus = document.querySelector('#sketch-tool-plus');\n  var minus = document.querySelector('#sketch-tool-minus');\n  var value = document.querySelector('#thickness-value');\n  plus.addEventListener('click', function () {\n    var num = parseInt(value.innerHTML.split('px')[0]);\n    if (num < 25) {\n      value.innerHTML = \"\".concat(num + 1, \"px\");\n    }\n  });\n  minus.addEventListener('click', function () {\n    var num = parseInt(value.innerHTML.split('px')[0]);\n    if (num > 1) {\n      value.innerHTML = \"\".concat(num - 1, \"px\");\n    }\n  });\n}\nfunction initTextErase(sketchCanvas) {\n  sketchCanvas.addEventListener('click', function (e) {\n    var rect = SVG_CANVAS.createSVGRect();\n    rect.x = e.clientX - SVG_CANVAS_BOUNDS.left;\n    rect.y = e.clientY - SVG_CANVAS_BOUNDS.top;\n    rect.width = 1;\n    rect.height = 1;\n    var intersectionList = SVG_CANVAS.getIntersectionList(rect, null);\n    if (intersectionList.length === 0) {\n      return;\n    }\n    var topElement = intersectionList[intersectionList.length - 1];\n    if (topElement.classList.contains(TEXT_SVG_CLASS)) {\n      // don't delete something that isn't a sketch text\n      topElement.dispatchEvent(new MouseEvent('click'));\n    }\n  });\n}\n\n/**\r\n * text area special case moving\r\n * @param el the element that is moved\r\n * @param ctrl the element that controls the movement (activates moving)\r\n */\nfunction move(el, ctrl) {\n  var x1 = 0,\n    y1 = 0,\n    x2 = 0,\n    y2 = 0;\n  ctrl.onmousedown = function (down) {\n    x2 = down.clientX;\n    y2 = down.clientY;\n    document.onmouseup = function () {\n      return document.onmouseup = document.onmousemove = null;\n    };\n    document.onmousemove = function (move) {\n      x1 = x2 - move.clientX;\n      y1 = y2 - move.clientY;\n      x2 = move.clientX;\n      y2 = move.clientY;\n      var bounds = el.getBoundingClientRect();\n      if (el.offsetLeft - x1 < SVG_CANVAS_BOUNDS.left || el.offsetTop - y1 < SVG_CANVAS_BOUNDS.top || el.offsetLeft - x1 + bounds.width + ADDITIONAL_CANVAS_OFFSET_X > window.innerWidth || el.offsetTop - y1 + bounds.height + ADDITIONAL_CANVAS_OFFSET_Y > window.innerHeight) {\n        return;\n      }\n      el.style.top = el.offsetTop - y1 + 'px';\n      el.style.left = el.offsetLeft - x1 + 'px';\n    };\n  };\n}\n\n\n//# sourceURL=webpack://test_zav/./public/scripts/helpers/sketch.js?");

/***/ }),

/***/ "./public/scripts/models/AlgorithmModel.js":
/*!*************************************************!*\
  !*** ./public/scripts/models/AlgorithmModel.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AlgorithmModel)\n/* harmony export */ });\n/* harmony import */ var _algorithms_Dijkstra_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../algorithms/Dijkstra.js */ \"./public/scripts/algorithms/Dijkstra.js\");\n/* harmony import */ var _algorithms_decorators_animate_decorators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../algorithms/decorators/animate.decorators */ \"./public/scripts/algorithms/decorators/animate.decorators.js\");\n/* harmony import */ var _DrawingHelperModel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DrawingHelperModel */ \"./public/scripts/models/DrawingHelperModel.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\nvar AlgorithmModel = /*#__PURE__*/function () {\n  function AlgorithmModel() {\n    _classCallCheck(this, AlgorithmModel);\n  }\n  _createClass(AlgorithmModel, null, [{\n    key: \"passContainers\",\n    value: function passContainers(obj) {\n      // structuredClone performs deep copy, its needed because deleting or altering\n      // some of the properties below (in case of the shallow copying) would change\n      // data obtained from drawing.js and drawing wouldn't work\n      this.containers = structuredClone(obj);\n\n      // removing attributes that we don't need in addon.cc\n      this.containers.vertexContainer.forEach(function (vertex) {\n        delete vertex.SVG;\n        delete vertex.shape;\n        delete vertex.x;\n        delete vertex.y;\n        delete vertex.helper;\n      });\n      this.containers.edgeContainer.forEach(function (edge) {\n        delete edge.help;\n      });\n    }\n  }]);\n  return AlgorithmModel;\n}();\n_defineProperty(AlgorithmModel, \"containers\", void 0);\n\nfunction getButtons(str) {\n  return Array.from(document.querySelectorAll(\"[id^=\".concat(str, \"]\")));\n}\nvar v0Listeners = new Map();\nfunction v0Cleanup() {\n  v0Listeners.forEach(function (val, key) {\n    return key.removeEventListener('click', val);\n  });\n  v0Listeners.clear();\n}\nvar tableObserver = new MutationObserver(function () {\n  var runButtons = getButtons('run-alg-');\n  var fastForwardButtons = getButtons('fast-forward-alg-');\n  var doubleTimeButtons = getButtons('double-alg-');\n  var halfTimeButtons = getButtons('half-alg-');\n  var removeButtons = getButtons('remove-alg-');\n  var v0Buttons = getButtons('v0-alg-');\n  runButtons.forEach(function (btn) {\n    btn.addEventListener('click', function () {\n      var alg = btn.id.split('run-alg-')[1];\n      if (alg === 'Dijkstra-animated') {\n        _algorithms_Dijkstra_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].manageAnimated(AlgorithmModel.containers, true).then(function () {})[\"catch\"](function (err) {\n          return console.error(err);\n        });\n      } else if (alg === 'Dijkstra-performance') {\n        _algorithms_Dijkstra_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].managePerformance(AlgorithmModel.containers);\n      }\n    });\n  });\n  fastForwardButtons.forEach(function (btn) {\n    btn.addEventListener('click', function () {\n      var alg = btn.id.split('fast-forward-alg-')[1];\n      if (alg === 'Dijkstra-animated') {\n        _algorithms_Dijkstra_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].manageAnimated(AlgorithmModel.containers, false).then(function () {})[\"catch\"](function (err) {\n          return console.error(err);\n        });\n      }\n    });\n  });\n  doubleTimeButtons.forEach(function (btn) {\n    btn.addEventListener('click', function () {\n      return _algorithms_decorators_animate_decorators__WEBPACK_IMPORTED_MODULE_1__.TimeManager.getInstance().updateTime(0.5);\n    });\n  });\n  halfTimeButtons.forEach(function (btn) {\n    btn.addEventListener('click', function () {\n      return _algorithms_decorators_animate_decorators__WEBPACK_IMPORTED_MODULE_1__.TimeManager.getInstance().updateTime(2);\n    });\n  });\n  v0Buttons.forEach(function (btn) {\n    var v0Text = btn.querySelector('span sub');\n    btn.addEventListener('click', function () {\n      (0,_DrawingHelperModel__WEBPACK_IMPORTED_MODULE_2__.getAllVertices)().forEach(function (v) {\n        var id = (0,_DrawingHelperModel__WEBPACK_IMPORTED_MODULE_2__.getIDFromVertex)(v);\n        var onClick = function onClick() {\n          _algorithms_Dijkstra_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setSource(AlgorithmModel.containers.vertexContainer.find(function (el) {\n            return el.id === id;\n          }));\n          v0Text.innerText = id;\n        };\n        v.addEventListener('click', onClick);\n        v0Listeners.set(v, onClick);\n      });\n    });\n    var v0 = AlgorithmModel.containers.vertexContainer[0];\n    _algorithms_Dijkstra_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setSource(v0);\n    v0Text.innerText = v0 !== undefined ? v0.id : '?';\n  });\n  removeButtons.forEach(function (btn) {\n    btn.addEventListener('click', function () {\n      return v0Cleanup();\n    });\n  });\n});\nvar openAlgorithm = document.querySelector('#algorithm');\nvar closeAlgorithm = document.querySelector('#algorithm-heading > img');\nvar toolbarContainer = document.querySelector('.toolbar-container');\nopenAlgorithm.addEventListener('click', function () {\n  // observed element, option object\n  var table = document.querySelector('#selected-algorithms-table');\n  tableObserver.observe(table, {\n    childList: true\n  });\n\n  // freeze toolbar when algorithm div opens\n  toolbarContainer.style.pointerEvents = 'none';\n});\ncloseAlgorithm.addEventListener('click', function () {\n  // clear selected algorithms\n  var removeButtons = getButtons('remove-alg-');\n  removeButtons.forEach(function (btn) {\n    return btn.click();\n  });\n\n  // boost performance, use observer only when div is displayed\n  tableObserver.disconnect();\n\n  // unfreeze toolbar when algorithm div opens\n  toolbarContainer.style.pointerEvents = 'auto';\n\n  // remove listeners\n  v0Cleanup();\n});\n\n//# sourceURL=webpack://test_zav/./public/scripts/models/AlgorithmModel.js?");

/***/ }),

/***/ "./public/scripts/models/ClientDefaultsModel.js":
/*!******************************************************!*\
  !*** ./public/scripts/models/ClientDefaultsModel.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"clickOptions\": () => (/* binding */ clickOptions),\n/* harmony export */   \"insertGraphCenter\": () => (/* binding */ insertGraphCenter),\n/* harmony export */   \"insertGraphRadius\": () => (/* binding */ insertGraphRadius)\n/* harmony export */ });\nvar insertGraphRadius = 230;\nvar insertGraphCenter = function insertGraphCenter(leftOffset, topOffset, width, height) {\n  return [leftOffset + width / 2, topOffset + height / 2 - 25];\n};\nvar clickOptions = {\n  'view': window,\n  'bubbles': true,\n  // the event is going up through the DOM tree\n  'cancelable': true,\n  // event can be canceled\n  'clientX': undefined,\n  'clientY': undefined\n};\n\n//# sourceURL=webpack://test_zav/./public/scripts/models/ClientDefaultsModel.js?");

/***/ }),

/***/ "./public/scripts/models/DeleteEdgeModel.js":
/*!**************************************************!*\
  !*** ./public/scripts/models/DeleteEdgeModel.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"removeWrappers\": () => (/* binding */ removeWrappers),\n/* harmony export */   \"setWrappers\": () => (/* binding */ setWrappers)\n/* harmony export */ });\n/* harmony import */ var _DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DrawingHelperModel.js */ \"./public/scripts/models/DrawingHelperModel.js\");\n/* harmony import */ var _models_ClientDefaultsModel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../models/ClientDefaultsModel.js */ \"./public/scripts/models/ClientDefaultsModel.js\");\n/* harmony import */ var _VertexModel_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexModel.js */ \"./public/scripts/models/VertexModel.js\");\n\n\n\n\n/**\r\n * creates the SVG elements that are initially invisible, once an\r\n * element with an id <code>delete-upper-edge-[number]</code> gets\r\n * hovered, it remains invisible, but the element with the id\r\n * <code>delete-lower-edge-[number]</code> shows up as the\r\n * dashed-like line following an edge\r\n *\r\n * when the upper element gets clicked, both of the elements will\r\n * be removed and the operation of removing the edge and\r\n * belonging vertices will be performed\r\n *\r\n * wrappers are created and removed when entering and leaving\r\n * <code>Tool.DELETE</code> mode, this behaviour is managed\r\n * in the drawing.js\r\n * @param edgeContainer\r\n */\nfunction setWrappers(edgeContainer) {\n  edgeContainer.forEach(function (edge) {\n    var SVGEdgeElement = _DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_0__.getEdgeFromID(edge.id);\n    var SVGEdgeDelete = SVGEdgeElement.cloneNode(false);\n    SVGEdgeDelete.setAttribute('id', 'delete-' + SVGEdgeElement.id);\n    SVGEdgeDelete.setAttribute('stroke-width', '10');\n    SVGEdgeDelete.style.strokeOpacity = '0';\n    var oldStroke = SVGEdgeElement.getAttribute('stroke');\n    var oldStrokeWidth = SVGEdgeElement.getAttribute('stroke-width');\n    SVGEdgeDelete.onmouseover = function () {\n      SVGEdgeElement.setAttribute('stroke', 'red');\n      SVGEdgeElement.setAttribute('stroke-width', '10');\n      SVGEdgeElement.setAttribute('stroke-dasharray', '5,2.5');\n    };\n    SVGEdgeDelete.onmouseout = function () {\n      SVGEdgeElement.setAttribute('stroke', oldStroke);\n      SVGEdgeElement.setAttribute('stroke-width', oldStrokeWidth);\n      SVGEdgeElement.removeAttribute('stroke-dasharray');\n    };\n    SVGEdgeDelete.onclick = function () {\n      var event = new MouseEvent('click', _models_ClientDefaultsModel_js__WEBPACK_IMPORTED_MODULE_1__.clickOptions);\n      SVGEdgeElement.dispatchEvent(event);\n    };\n    document.querySelector('.canvas').append(SVGEdgeDelete);\n    (0,_VertexModel_js__WEBPACK_IMPORTED_MODULE_2__.restore)(_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_0__.getVertexFromID(edge.connection[0]), _DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_0__.getVertexFromID(edge.connection[1]), _DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_0__.getTextFromID(edge.connection[0]), _DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_0__.getTextFromID(edge.connection[1]));\n  });\n}\nfunction removeWrappers() {\n  _DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_0__.getAll('[id^=\"delete-edge-id-\"]').forEach(function (del) {\n    return del.remove();\n  });\n}\n\n\n//# sourceURL=webpack://test_zav/./public/scripts/models/DeleteEdgeModel.js?");

/***/ }),

/***/ "./public/scripts/models/DrawingConstraintModel.js":
/*!*********************************************************!*\
  !*** ./public/scripts/models/DrawingConstraintModel.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isAllowedByArrowSize\": () => (/* binding */ isAllowedByArrowSize),\n/* harmony export */   \"isAllowedByVertexSize\": () => (/* binding */ isAllowedByVertexSize),\n/* harmony export */   \"isAllowedByWeightItemSize\": () => (/* binding */ isAllowedByWeightItemSize)\n/* harmony export */ });\nfunction isAllowedByVertexSize(x, y, vertex, canvasOffset) {\n  var vertexOffset = vertex.getBoundingClientRect();\n  var strokeWidth = parseInt(vertex.getAttribute('stroke-width'));\n  return !(x - vertexOffset.width / 2 - strokeWidth < canvasOffset.left || y - vertexOffset.height / 2 - strokeWidth < canvasOffset.top || x + vertexOffset.width / 2 + strokeWidth + ADDITIONAL_CANVAS_OFFSET_X > canvasOffset.right || y + vertexOffset.height / 2 + strokeWidth + ADDITIONAL_CANVAS_OFFSET_Y > canvasOffset.bottom);\n  // TODO canvas padding bottom and right (5)\n}\n\nfunction isAllowedByArrowSize(arrowOffset, canvasOffset, loopOffset) {\n  return loopOffset.left - arrowOffset.width / 2 - canvasOffset.left >= 0 && loopOffset.top - arrowOffset.height / 2 - canvasOffset.top >= 0;\n}\nfunction isAllowedByWeightItemSize(weightItemOffset, canvasOffset, loopOffset) {\n  return loopOffset.left - weightItemOffset.width / 2 - canvasOffset.left >= 0 && loopOffset.top - weightItemOffset.height / 2 - canvasOffset.top >= 0;\n}\n\n// TODO - add warning card when outside of the canvas and when user tries to DRAW a loop outside\n\n\n\n//# sourceURL=webpack://test_zav/./public/scripts/models/DrawingConstraintModel.js?");

/***/ }),

/***/ "./public/scripts/models/DrawingHelperModel.js":
/*!*****************************************************!*\
  !*** ./public/scripts/models/DrawingHelperModel.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PATH_START_REGEX\": () => (/* binding */ PATH_START_REGEX),\n/* harmony export */   \"addWeightItem\": () => (/* binding */ addWeightItem),\n/* harmony export */   \"addWeightText\": () => (/* binding */ addWeightText),\n/* harmony export */   \"changeArrowDirection\": () => (/* binding */ changeArrowDirection),\n/* harmony export */   \"countCommonElements\": () => (/* binding */ countCommonElements),\n/* harmony export */   \"createFace\": () => (/* binding */ createFace),\n/* harmony export */   \"expand\": () => (/* binding */ expand),\n/* harmony export */   \"findPolygonPoints\": () => (/* binding */ findPolygonPoints),\n/* harmony export */   \"getAll\": () => (/* binding */ getAll),\n/* harmony export */   \"getAllEdges\": () => (/* binding */ getAllEdges),\n/* harmony export */   \"getAllVertices\": () => (/* binding */ getAllVertices),\n/* harmony export */   \"getArrowFromID\": () => (/* binding */ getArrowFromID),\n/* harmony export */   \"getCenter\": () => (/* binding */ getCenter),\n/* harmony export */   \"getConnection\": () => (/* binding */ getConnection),\n/* harmony export */   \"getConnectionCount\": () => (/* binding */ getConnectionCount),\n/* harmony export */   \"getDeleteEdgeFromID\": () => (/* binding */ getDeleteEdgeFromID),\n/* harmony export */   \"getEdgeFromID\": () => (/* binding */ getEdgeFromID),\n/* harmony export */   \"getIDFromArrow\": () => (/* binding */ getIDFromArrow),\n/* harmony export */   \"getIDFromEdge\": () => (/* binding */ getIDFromEdge),\n/* harmony export */   \"getIDFromText\": () => (/* binding */ getIDFromText),\n/* harmony export */   \"getIDFromVertex\": () => (/* binding */ getIDFromVertex),\n/* harmony export */   \"getIDFromWeightText\": () => (/* binding */ getIDFromWeightText),\n/* harmony export */   \"getLineCenter\": () => (/* binding */ getLineCenter),\n/* harmony export */   \"getLoopCenter\": () => (/* binding */ getLoopCenter),\n/* harmony export */   \"getPointsFromArc\": () => (/* binding */ getPointsFromArc),\n/* harmony export */   \"getPointsFromLine\": () => (/* binding */ getPointsFromLine),\n/* harmony export */   \"getTextFromID\": () => (/* binding */ getTextFromID),\n/* harmony export */   \"getVertexFromID\": () => (/* binding */ getVertexFromID),\n/* harmony export */   \"getWeightData\": () => (/* binding */ getWeightData),\n/* harmony export */   \"getWeightInputs\": () => (/* binding */ getWeightInputs),\n/* harmony export */   \"getWeightItemFromID\": () => (/* binding */ getWeightItemFromID),\n/* harmony export */   \"getWeightSpans\": () => (/* binding */ getWeightSpans),\n/* harmony export */   \"getWeightTextFromID\": () => (/* binding */ getWeightTextFromID),\n/* harmony export */   \"loopToVertex\": () => (/* binding */ loopToVertex),\n/* harmony export */   \"moveArrowForWeight\": () => (/* binding */ moveArrowForWeight),\n/* harmony export */   \"moveLoop\": () => (/* binding */ moveLoop),\n/* harmony export */   \"recon\": () => (/* binding */ recon),\n/* harmony export */   \"removeWeights\": () => (/* binding */ removeWeights),\n/* harmony export */   \"restoreAll\": () => (/* binding */ restoreAll),\n/* harmony export */   \"rotateLoop\": () => (/* binding */ rotateLoop),\n/* harmony export */   \"rotateLoopSetup\": () => (/* binding */ rotateLoopSetup),\n/* harmony export */   \"setWeightData\": () => (/* binding */ setWeightData),\n/* harmony export */   \"shrink\": () => (/* binding */ shrink),\n/* harmony export */   \"toggleButtonsExcept\": () => (/* binding */ toggleButtonsExcept),\n/* harmony export */   \"updateArrowOnCreate\": () => (/* binding */ updateArrowOnCreate),\n/* harmony export */   \"updateArrowOnLineMove\": () => (/* binding */ updateArrowOnLineMove),\n/* harmony export */   \"updateArrowOnLoopMove\": () => (/* binding */ updateArrowOnLoopMove),\n/* harmony export */   \"updateWeightOnMove\": () => (/* binding */ updateWeightOnMove)\n/* harmony export */ });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n// browser angle is 0 at 3 o'clock while CSS transform angle is at 12 o'clock,\n// so adjustments are needed when combining these two approaches\nvar BROWSER_VS_CSS_OFFSET = 270;\nvar ROTATE_CIRCLE_OFFSET = 15;\nvar TEXT_Y_OFFSET = 1.8;\nvar TEXT_R_L_OFFSET = 2.5;\nvar PATH_DIFFERENTIAL = 0.01;\n\n// regular expressions for 'd' attribute of the SVG elements\nvar PATH_START_REGEX = new RegExp(/M\\s\\d+(\\.\\d+)?\\s\\d+(\\.\\d+)?\\s/); // path's first coordinate\nvar FLOAT_REGEX = new RegExp(/[+-]?\\d+(\\.\\d+)?/);\nvar LINE_REGEX = getLineRegex();\nvar LOOP_REGEX = getLoopRegex();\nvar ARROW_REGEX = getArrowRegex();\nvar HELP_TRIANGLE_REGEX = getHelpTriangleRegex();\nfunction concatRegExp(exp1, exp2) {\n  // source : https://masteringjs.io/tutorials/fundamentals/concat-regexp\n  var flags = exp1.flags + exp2.flags;\n  flags = Array.from(new Set(flags.split(''))).join();\n  return new RegExp(exp1.source + exp2.source, flags);\n}\nfunction getLineRegex() {\n  var floatWithSpace = concatRegExp(FLOAT_REGEX, /\\s/);\n  var lineRegex = addRegexNTimes(/M\\s/, floatWithSpace, 2);\n  lineRegex = concatRegExp(lineRegex, /l\\s/);\n  lineRegex = concatRegExp(lineRegex, floatWithSpace);\n  lineRegex = concatRegExp(lineRegex, FLOAT_REGEX);\n  return lineRegex;\n}\nfunction getLoopRegex() {\n  var floatWithSpace = concatRegExp(FLOAT_REGEX, /\\s/);\n  var loopRegex = addRegexNTimes(/M\\s/, floatWithSpace, 2);\n  var isLast = false;\n  for (var i = 0; i < 4; i++) {\n    if (i === 3) {\n      isLast = true;\n    }\n    loopRegex = concatRegExp(loopRegex, /a\\s/);\n    loopRegex = addRegexNTimes(loopRegex, floatWithSpace, 7, isLast);\n  }\n  return loopRegex;\n}\nfunction getArrowRegex() {\n  var floatWithSpace = concatRegExp(FLOAT_REGEX, /\\s/);\n  var loopRegex = addRegexNTimes(/M\\s/, floatWithSpace, 2);\n  var isLast = false;\n  for (var i = 0; i < 5; i++) {\n    if (i === 4) {\n      isLast = true;\n    }\n    loopRegex = concatRegExp(loopRegex, /l\\s/);\n    loopRegex = addRegexNTimes(loopRegex, floatWithSpace, 2, isLast);\n  }\n  return loopRegex;\n}\nfunction getHelpTriangleRegex() {\n  var floatWithSpace = concatRegExp(FLOAT_REGEX, /\\s/);\n  // help triangle is similar to an arrow, but it has one more letter 'l' and two floats\n  var loopRegex = getArrowRegex();\n  loopRegex = concatRegExp(loopRegex, /\\sl\\s/);\n  loopRegex = concatRegExp(loopRegex, floatWithSpace);\n  loopRegex = concatRegExp(loopRegex, FLOAT_REGEX);\n  return loopRegex;\n}\nfunction addRegexNTimes(source, addition, n, isLast) {\n  for (var i = 0; i < n; i++) {\n    if (isLast && i === n - 1) {\n      addition = FLOAT_REGEX;\n    }\n    source = concatRegExp(source, addition);\n  }\n  return source;\n}\n\n/**\r\n * @returns array of all elements in drawing canvas instead of NodeList\r\n */\nfunction getAll(selector) {\n  return Array.prototype.slice.call(document.querySelectorAll(selector));\n}\nfunction getAllVertices() {\n  return getAll('[id^=\"vertex-id-\"]');\n}\nfunction getAllEdges() {\n  return getAll('[id^=\"edge-id-\"]');\n}\nfunction getAllTexts() {\n  return getAll('[id^=\"text-id-\"]');\n}\nfunction getAllArrows() {\n  return getAll('[id^=\"arrow-id-\"]');\n}\nfunction getAllWeightItems() {\n  return getAll('[id^=\"weight-item-id-\"]');\n}\nfunction getAllWeightTexts() {\n  return getAll('[id^=\"weight-text-id-\"]');\n}\nfunction getVertexFromID(id) {\n  return document.querySelector(\"#vertex-id-\".concat(id));\n}\nfunction getEdgeFromID(id) {\n  return document.querySelector(\"#edge-id-\".concat(id));\n}\nfunction getTextFromID(id) {\n  return document.querySelector(\"#text-id-\".concat(id));\n}\nfunction getArrowFromID(id) {\n  return document.querySelector(\"#arrow-id-\".concat(id));\n}\nfunction getWeightItemFromID(id) {\n  return document.querySelector(\"#weight-item-id-\".concat(id));\n}\nfunction getWeightTextFromID(id) {\n  return document.querySelector(\"#weight-text-id-\".concat(id));\n}\nfunction getWeightInputFromID(id) {\n  return document.querySelector(\"#weight-table-input-\".concat(id));\n}\nfunction getDeleteEdgeFromID(id) {\n  return document.querySelector(\"#delete-edge-id-\".concat(id));\n}\nfunction getIDFromVertex(el) {\n  return parseInt(el.getAttribute('id').split('vertex-id-')[1]);\n}\nfunction getIDFromEdge(el) {\n  return parseInt(el.getAttribute('id').split('edge-id-')[1]);\n}\nfunction getIDFromText(el) {\n  return parseInt(el.getAttribute('id').split('text-id-')[1]);\n}\nfunction getIDFromArrow(el) {\n  return parseInt(el.getAttribute('id').split('arrow-id-')[1]);\n}\nfunction getIDFromWeightText(el) {\n  return parseInt(el.getAttribute('id').split('weight-text-id-')[1]);\n}\nfunction loopToVertex(loop) {\n  return getVertexFromID(parseInt(loop.getAttribute('CA-connection').split(',')[0]));\n}\nfunction getPointsFromLine(line) {\n  var d = line.getAttribute('d').split(' ');\n  return [parseFloat(d[1]), parseFloat(d[2]), parseFloat(d[4]), parseFloat(d[5])];\n}\nfunction getPointsFromArc(arc) {\n  var d = arc.getAttribute('d').split(' ');\n  return [parseFloat(d[1]), parseFloat(d[2]), parseFloat(d[6]), parseFloat(d[7])];\n}\nfunction getConnection(edge) {\n  return edge.getAttribute('CA-connection').split(',').map(function (id) {\n    return parseInt(id);\n  });\n}\nfunction getConnectionCount(v1ID, v2ID) {\n  return getAllEdges().filter(function (edge) {\n    return _.sortBy(getConnection(edge)) === _.sortBy([v1ID, v2ID]);\n  }).length;\n}\nfunction getCenter(vertex) {\n  return {\n    x: parseFloat(vertex.getAttribute('CA-center-x')),\n    y: parseFloat(vertex.getAttribute('CA-center-y'))\n  };\n}\nvar Point = /*#__PURE__*/_createClass(function Point(x, y) {\n  _classCallCheck(this, Point);\n  this.x = x;\n  this.y = y;\n});\nfunction getDistance(p, q) {\n  return Math.sqrt(Math.pow(q.x - p.x, 2) + Math.pow(q.y - p.y, 2));\n}\nfunction getAngleFromSlope(p, q) {\n  var angle = Math.atan2(p.y - q.y, p.x - q.x);\n  if (angle < 0) angle += 2 * Math.PI;\n  return angle % (2 * Math.PI);\n}\n\n/**\r\n * get angle from 3 points where one of them is the origin (0,0) of coordinate system,\r\n * while coordinates of other points (p and q) are relative to the origin\r\n * @param p\r\n * @param q\r\n * @returns {number}\r\n */\nfunction getAngleFrom3Points(p, q) {\n  return Math.acos((p.x * q.x + p.y * q.y) / (Math.sqrt(Math.pow(p.x, 2) + Math.pow(p.y, 2)) * Math.sqrt(Math.pow(q.x, 2) + Math.pow(q.y, 2))));\n}\nfunction normalize(angle) {\n  if (angle < 0) angle += 2 * Math.PI;\n  return angle % (2 * Math.PI);\n}\nfunction getPointOnCircle(p1, p2, angle) {\n  angle += BROWSER_VS_CSS_OFFSET; // difference between JS and CSS\n  angle < 0 ? angle %= 360 : undefined;\n  angle *= Math.PI / 180;\n  var d = getDistance(p1, p2);\n  return new Point(d * Math.cos(angle) + p1.x, d * Math.sin(angle) + p1.y);\n}\n\n/**\r\n * get specific point on given path\r\n * @param path\r\n * @param lengthDivisor - ex. if it is 2, returned point will be at the half of total length\r\n * @returns {Point}\r\n */\nfunction getPartOfPath(path, lengthDivisor) {\n  var p = path.getPointAtLength(path.getTotalLength() / lengthDivisor);\n  return new Point(p.x, p.y);\n}\n\n/**\r\n * rotates relative part of the SVG 'd' attribute\r\n * @param el - 'd' attribute of an element must contain lowercase 'l' (relative lineTo)\r\n * letters followed by two numbers only\r\n * @param angle - angle in radians\r\n * @returns {string}\r\n */\nfunction rotateLineElement(el, angle) {\n  var arr1 = el.getAttribute('d').trim().split(' ');\n  var arr2 = [];\n  arr1 = _.drop(arr1, 3); // remove first 3 elements from an array\n\n  console.assert(arr1.length % 3 === 0);\n  for (var i = 0; i < arr1.length; i++) {\n    if ((i + 1) % 3 === 1) {\n      // arr1[i] is 'l'\n      arr2[i] = arr1[i];\n    } else if ((i + 1) % 3 === 2) {\n      // arr1[i] is x-axis coordinate\n      arr2[i] = (arr1[i] * Math.cos(angle) - arr1[i + 1] * Math.sin(angle)).toString();\n    } else {\n      // arr1[i] is y-axis coordinate\n      arr2[i] = (arr1[i - 1] * Math.sin(angle) + arr1[i] * Math.cos(angle)).toString();\n    }\n  }\n  return arr2.join(' ');\n}\nfunction rotateLoopElement(el, angle) {\n  var d = el.getAttribute('d');\n  console.assert(d.match(LOOP_REGEX)[0] === d);\n  var arr1 = d.split(' ');\n  var arr2 = [];\n  arr1 = _.drop(arr1, 3); // remove first 3 elements from an array\n\n  console.assert(arr1.length % 8 === 0);\n  for (var i = 0; i < arr1.length; i++) {\n    if (1 <= (i + 1) % 8 && (i + 1) % 8 <= 6) {\n      // arr1[i] is 'l'\n      arr2[i] = arr1[i];\n    } else if ((i + 1) % 8 === 7) {\n      // arr1[i] is x-axis coordinate\n      // toFixed(4) - rounding on four decimals in order to avoid scientific notation (avoid\n      // console.assert error when comparing the 'd' attribute with the regex)\n      arr2[i] = (arr1[i] * Math.cos(angle) - arr1[i + 1] * Math.sin(angle)).toFixed(4).toString();\n    } else if ((i + 1) % 8 === 0) {\n      // arr1[i] is y-axis coordinate\n      arr2[i] = (arr1[i - 1] * Math.sin(angle) + arr1[i] * Math.cos(angle)).toFixed(4).toString();\n    }\n  }\n  return arr2.join(' ');\n}\nfunction getRestOfRegex(el) {\n  var d = el.getAttribute('d').trim();\n  var elStart = d.match(PATH_START_REGEX)[0];\n  return d.replace(elStart, '');\n}\n\n/**\r\n * checking whether two arrays have the only one common element\r\n * @param arr1\r\n * @param arr2\r\n * @returns {number}\r\n */\nfunction countCommonElements(arr1, arr2) {\n  var count = 0;\n  arr1.forEach(function (el1) {\n    return arr2.forEach(function (el2) {\n      if (el1 === el2) count++;\n    });\n  });\n  return count;\n}\n\n/**\r\n * calculates n points of polygon from given coordinates and returns them as a string\r\n * @param x - cursor coordinate\r\n * @param y - cursor coordinate\r\n * @param a - polygon base\r\n * @param n - number of angles\r\n * @returns {string} points are separated by comma\r\n */\nvar findPolygonPoints = function findPolygonPoints(x, y, a, n) {\n  var beta = 2 * Math.PI / n;\n  var r = a / (2 * Math.sin(beta / 2));\n  var points = \"\";\n  for (var i = 0; i < n; i++) {\n    var theta = -Math.PI / 2 + 2 * Math.PI * i / n;\n    points += \"\".concat(x + r * Math.cos(theta) + ',' + (y + r * Math.sin(theta)) + ' ');\n  }\n  return points;\n};\nvar moveLoop = function moveLoop(edge, relativeX, relativeY) {\n  var edgeStart = edge.getAttribute('d').match(PATH_START_REGEX)[0];\n  var edgeRest = edge.getAttribute('d').replace(edgeStart, '');\n  edge.setAttribute('d', \"M \".concat(relativeX, \" \").concat(relativeY, \" \") + edgeRest);\n};\n\n/**\r\n * updates arrow position right after the arrow was created\r\n * for both types of edges (line and loop)\r\n */\nvar updateArrowOnCreate = function updateArrowOnCreate(id) {\n  var arrow = getArrowFromID(id);\n  var edge = getEdgeFromID(id);\n  var p = getPartOfPath(edge, 2);\n  var q = getPartOfPath(edge, 2 + PATH_DIFFERENTIAL);\n  var angle = normalize(Math.atan2(p.y - q.y, p.x - q.x));\n  // if we are in 1st or 4th quadrant, we have to add PI, otherwise\n  // an arrow would be pointed in the wrong direction\n  if (0 <= angle <= Math.PI || 3 * Math.PI / 2 <= angle <= 2 * Math.PI) {\n    angle += Math.PI;\n  }\n  angle %= 2 * Math.PI;\n  arrow.setAttribute('d', \"M \".concat(p.x, \" \").concat(p.y, \" \") + rotateLineElement(arrow, angle));\n  arrow.setAttribute('prev-angle', angle.toString());\n};\nvar updateArrowOnLineMove = function updateArrowOnLineMove(id, isWeighted) {\n  var p, q;\n  var edge = getEdgeFromID(id);\n  var arrow = getArrowFromID(id);\n  if (isWeighted) {\n    p = getPartOfPath(edge, 4);\n    q = getPartOfPath(edge, 4 + PATH_DIFFERENTIAL);\n  } else {\n    p = getPartOfPath(edge, 2);\n    q = getPartOfPath(edge, 2 + PATH_DIFFERENTIAL);\n  }\n  var angle = normalize(Math.atan2(p.y - q.y, p.x - q.x));\n  if (0 <= angle <= Math.PI || 3 * Math.PI / 2 <= angle <= 2 * Math.PI) {\n    angle += Math.PI;\n    angle %= 2 * Math.PI;\n  }\n  var diff = 0;\n  var prevAngle = arrow.getAttribute('prev-angle');\n  if (prevAngle !== null) {\n    diff = angle - parseFloat(prevAngle);\n  }\n  arrow.setAttribute('d', \"M \".concat(p.x, \" \").concat(p.y, \" \") + rotateLineElement(arrow, diff));\n  arrow.setAttribute('prev-angle', angle.toString());\n};\n\n/**\r\n * updates arrow position if edge is a loop\r\n */\nvar updateArrowOnLoopMove = function updateArrowOnLoopMove(id, isDirected, isWeighted) {\n  var p;\n  var edge = getEdgeFromID(id);\n  var arrow = getArrowFromID(id);\n  isDirected && isWeighted ? p = getPartOfPath(edge, 4) : p = getPartOfPath(edge, 2);\n  var arrowStart = arrow.getAttribute('d').match(PATH_START_REGEX)[0];\n  var arrowEnd = arrow.getAttribute('d').replace(arrowStart, '');\n  arrow.setAttribute('d', \"M \".concat(p.x, \" \").concat(p.y, \" \") + arrowEnd);\n};\nvar rotateLoopSetup = function rotateLoopSetup(vertex, edge) {\n  // coordinates of center of any shape\n  var x = 0,\n    y = 0;\n  var r = ROTATE_CIRCLE_OFFSET; // radius for helper circle\n  var shape = vertex.getAttribute('shape');\n  var id = getIDFromVertex(vertex);\n  switch (shape) {\n    case 'circle':\n      r += parseFloat(vertex.getAttribute('r'));\n      x = parseFloat(vertex.getAttribute('cx'));\n      y = parseFloat(vertex.getAttribute('cy'));\n      break;\n    case 'square':\n      var width = parseFloat(vertex.getAttribute('width'));\n      r += width * Math.sqrt(2) / 2;\n      x = parseFloat(vertex.getAttribute('x')) + width / 2;\n      y = parseFloat(vertex.getAttribute('y')) + width / 2;\n      break;\n    case 'rectangle':\n      var width2 = parseFloat(vertex.getAttribute('width'));\n      var height = parseFloat(vertex.getAttribute('height'));\n      x = parseFloat(vertex.getAttribute('x')) + width2 / 2;\n      y = parseFloat(vertex.getAttribute('y')) + height / 2;\n      r += Math.sqrt(Math.pow(width2, 2) + Math.pow(height, 2)) / 2;\n      break;\n    case 'triangle':\n      r += Math.sqrt(3) / 3 * parseFloat(vertex.getAttribute('polygon-base'));\n      break;\n    case 'polygon':\n      var alpha = 2 * Math.PI / parseFloat(vertex.getAttribute('number-of-angles'));\n      r += parseFloat(vertex.getAttribute('polygon-base')) / (2 * Math.sin(alpha / 2));\n      break;\n  }\n  if (shape === 'polygon' || shape === 'triangle') {\n    var n = parseFloat(vertex.getAttribute('number-of-angles'));\n    var points = vertex.getAttribute('points').replaceAll(',', ' ').split(' ');\n    points = points.filter(function (point) {\n      return point !== '';\n    });\n    points = points.map(function (point) {\n      return parseFloat(point);\n    });\n    for (var i = 0; i < points.length; i++) {\n      i % 2 === 0 ? x += points[i] : y += points[i];\n    }\n    x /= n;\n    y /= n;\n  }\n  var helpCircle = document.createElementNS(SVG_NS_URI, 'circle');\n  var attrs = ['id', 'cx', 'cy', 'r', 'fill', 'stroke', 'stroke-width', 'stroke-dasharray'];\n  var values = [\"circle-rotate-\".concat(id), \"\".concat(x), \"\".concat(y), \"\".concat(r), 'none', 'midnightblue', '1', '2'];\n  for (var _i = 0; _i < attrs.length; _i++) {\n    helpCircle.setAttribute(attrs[_i], values[_i]);\n  }\n  var helpTriangle = document.createElementNS(SVG_NS_URI, 'path');\n  attrs = ['id', 'fill', 'stroke', 'stroke-width', 'd'];\n  values = [\"triangle-rotate-\".concat(id), 'none', 'midnightblue', '5', \"M \".concat(x, \" \").concat(y - r, \" l 0 -5.196 l 6 0 l -6 10.39 l -6 -10.39 l 12 0 l -6 10.39\")];\n  for (var _i2 = 0; _i2 < attrs.length; _i2++) {\n    helpTriangle.setAttribute(attrs[_i2], values[_i2]);\n  }\n\n  // 'prev-angle' is set in rotateLoop (if the loop gets rotated by rotate tool)\n  var angle = edge.getAttribute('prev-angle');\n  if (angle !== null) {\n    var edgeStart = edge.getAttribute('d').trim().match(PATH_START_REGEX)[0];\n    edgeStart = edgeStart.trim().split(' ');\n    edgeStart = new Point(parseFloat(edgeStart[1]), parseFloat(edgeStart[2]));\n    helpTriangle.setAttribute('d', \"M \".concat(r * Math.cos(angle) + edgeStart.x, \" \").concat(r * Math.sin(angle) + edgeStart.y, \" \") + rotateLineElement(helpTriangle, angle - 3 / 2 * Math.PI));\n  }\n  return [helpCircle, helpTriangle];\n};\nvar rotateLoop = function rotateLoop(id, clientX, clientY, helpTriangle, helpCircle, isDirected, isWeighted) {\n  var edge = getEdgeFromID(id);\n  var center = edge.getPointAtLength(0);\n  var p = new Point(clientX, clientY);\n  var q = new Point(center.x, center.y);\n  var r = parseFloat(helpCircle.getAttribute('r'));\n  var angle = normalize(Math.atan2(p.y - q.y, p.x - q.x));\n  var diff;\n  var prevAngle = edge.getAttribute('prev-angle');\n  if (prevAngle === null) {\n    p = getPartOfPath(edge, 2);\n    var angle2 = Math.atan2(p.y - q.y, p.x - q.x);\n    if (angle2 < 0) angle2 += 2 * Math.PI;\n    angle2 %= 2 * Math.PI;\n    diff = angle - angle2;\n  } else {\n    diff = angle - parseFloat(prevAngle);\n  }\n  edge.setAttribute('d', edge.getAttribute('d').trim().match(PATH_START_REGEX)[0] + rotateLoopElement(edge, diff));\n  edge.setAttribute('prev-angle', angle.toString());\n  var edgeStart = edge.getAttribute('d').trim().match(PATH_START_REGEX)[0];\n  edgeStart = edgeStart.trim().split(' ');\n  edgeStart = new Point(parseFloat(edgeStart[1]), parseFloat(edgeStart[2]));\n  helpTriangle.setAttribute('d', \"M \".concat(r * Math.cos(angle) + edgeStart.x, \" \").concat(r * Math.sin(angle) + edgeStart.y, \" \") + rotateLineElement(helpTriangle, diff));\n  if (isDirected) {\n    var arrow = getArrowFromID(id);\n    var _p = getPartOfPath(edge, 2);\n    var _angle = normalize(Math.atan2(_p.y - q.y, _p.x - q.x));\n    var _diff = 0;\n    var _prevAngle = arrow.getAttribute('prev-angle');\n    if (_prevAngle !== null) {\n      _diff = _angle - parseFloat(_prevAngle);\n    }\n    if (isWeighted) {\n      var t = getPartOfPath(edge, 4);\n      var _q = edge.getPointAtLength(0);\n      _q = new Point(_q.x, _q.y);\n      t.x -= _q.x;\n      t.y -= _q.y;\n      _q.x = _q.y = 0;\n      _diff = getAngleFromSlope(_q, t);\n      if (_prevAngle !== null) {\n        _diff -= parseFloat(_prevAngle);\n      }\n      _diff = (_diff + Math.PI) % (2 * Math.PI);\n      _p = getPartOfPath(edge, 4);\n      _angle = normalize(Math.atan2(t.y - _q.y, t.x - _q.x));\n    }\n    arrow.setAttribute('d', \"M \".concat(_p.x, \" \").concat(_p.y, \" \") + rotateLineElement(arrow, _diff));\n    arrow.setAttribute('prev-angle', _angle.toString());\n  }\n};\n\n/**\r\n * rotate arrow for 180 degrees\r\n * @param id\r\n */\nvar changeArrowDirection = function changeArrowDirection(id) {\n  var arrow = getArrowFromID(id);\n  var arrowStart = arrow.getAttribute('d').trim().match(PATH_START_REGEX)[0];\n  arrow.setAttribute('d', arrowStart + rotateLineElement(arrow, Math.PI));\n};\nvar getWeightSpans = function getWeightSpans() {\n  var span1 = document.createElement('span');\n  span1.innerHTML = 'Edge id';\n  var span2 = document.createElement('span');\n  span2.innerHTML = 'Weight';\n  return [span1, span2];\n};\nvar getWeightInputs = function getWeightInputs(id, weight) {\n  var label = document.createElement('label');\n  label.setAttribute('id', \"weight-table-label-\".concat(id));\n  label.innerHTML = id;\n  var input = document.createElement('input');\n  input.setAttribute('id', \"weight-table-input-\".concat(id));\n  input.setAttribute('type', 'number');\n  input.setAttribute('min', '0');\n  input.setAttribute('oninput', 'validity.valid||(value=\\'\\');');\n  input.setAttribute('value', weight);\n  input.style.textAlign = 'center';\n  input.style.fontFamily = 'EncodeSans-Regular, serif';\n  return [label, input];\n};\n\n/**\r\n * center of the straight line, works only for the paths\r\n * @param edgeID\r\n * @returns {Point}\r\n */\nvar getLineCenter = function getLineCenter(edgeID) {\n  var svg = getEdgeFromID(edgeID);\n  var SVGPoint = getPartOfPath(svg, 2);\n  return new Point(SVGPoint.x, SVGPoint.y);\n};\n\n/**\r\n *  half of the loop length, not geometric center\r\n * @param edgeID\r\n * @returns {Point}\r\n */\nvar getLoopCenter = function getLoopCenter(edgeID) {\n  var svg = getEdgeFromID(edgeID);\n  var SVGPoint = getPartOfPath(svg, 2);\n  var transform = svg.getAttribute('transform');\n  if (transform === null) return new Point(SVGPoint.x, SVGPoint.y);\n  var angle = parseFloat(transform.match(/-*\\d+\\.*\\d*/)[0]);\n  var p1 = svg.getPointAtLength(0); // vertex center (beginning of the loop)\n  var p2 = getPartOfPath(svg, 2); // loop center\n\n  return getPointOnCircle(p1, p2, angle);\n};\nvar addWeightText = function addWeightText(edgeID, weight, isLine) {\n  var point;\n  isLine === true ? point = getLineCenter(edgeID) : point = getLoopCenter(edgeID);\n  var weightText = document.createElementNS(SVG_NS_URI, 'text');\n  var properties = [\"id\", \"x\", \"y\", \"dominant-baseline\", \"text-anchor\", \"font-size\", \"font-weight\", \"fill\", \"pointer-events\"];\n  var values = [\"weight-text-id-\".concat(edgeID), \"\".concat(point.x), \"\".concat(point.y + TEXT_Y_OFFSET), \"middle\", \"middle\", \"15px\", \"normal\", \"white\", \"none\"];\n  for (var i = 0; i < properties.length; i++) {\n    weightText.setAttribute(properties[i], values[i]);\n  }\n  weightText.style.userSelect = 'none';\n  weightText.textContent = \"\".concat(edgeID, \";\").concat(weight);\n  return weightText;\n};\nvar addWeightItem = function addWeightItem(edgeID, weightText, fill, isLine) {\n  var weightItem = document.createElementNS(SVG_NS_URI, 'path');\n  weightItem.setAttribute('id', \"weight-item-id-\".concat(edgeID));\n  weightItem.setAttribute('fill', fill);\n  var textLength, halfWidth;\n  var resize = function resize() {\n    textLength = weightText.getComputedTextLength();\n    halfWidth = textLength / 2 + TEXT_R_L_OFFSET;\n    if (halfWidth < 12.5) halfWidth = 12.5;\n    var point = isLine === true ? getLineCenter(edgeID) : getLoopCenter(edgeID);\n    weightItem.setAttribute('d', \"M \".concat(point.x, \" \").concat(point.y, \" \") + \"l 0 -12.5 l \".concat(halfWidth, \" 0 \") + \"l 0 25 l \".concat(-halfWidth * 2, \" 0 \") + \"l 0 -25 l \".concat(halfWidth, \" 0\"));\n  };\n  // setting weight item size for the first time\n  resize();\n\n  // setting weight item size whenever the weight gets changed\n  var observer = new MutationObserver(function () {\n    return resize();\n  });\n  observer.observe(weightText, {\n    characterData: false,\n    attributes: false,\n    childList: true,\n    subtree: false\n  });\n  return weightItem;\n};\nvar updateWeightOnMove = function updateWeightOnMove(id) {\n  var edge = getEdgeFromID(id);\n  var wItem = getWeightItemFromID(id);\n  var wText = getWeightTextFromID(id);\n  var p = getPartOfPath(edge, 2);\n  var matched = wItem.getAttribute('d').split(PATH_START_REGEX);\n  wItem.setAttribute('d', \"M \".concat(p.x, \" \").concat(p.y, \" \") + matched[matched.length - 1]);\n  wText.setAttribute('x', p.x.toString());\n  wText.setAttribute('y', (p.y + TEXT_Y_OFFSET).toString());\n};\nvar moveArrowForWeight = function moveArrowForWeight(id, arrowBody) {\n  var arrow = getArrowFromID(id);\n  var edge = getEdgeFromID(id);\n  var p = getPartOfPath(edge, 4);\n  if (edge.getAttribute('CA-type') === 'loop') {\n    arrow.setAttribute('d', \"M \".concat(p.x, \" \").concat(p.y, \" \") + arrowBody);\n    var q = edge.getPointAtLength(0);\n    // assigning new instance of the Point object because returned SVGPoint object is immutable\n    q = new Point(q.x, q.y);\n    // make p relative to q\n    p.x -= q.x;\n    p.y -= q.y;\n    // set q as the origin of coordinate system in order to find proper angle\n    q.x = q.y = 0;\n    var angle = getAngleFromSlope(q, p);\n    angle = (angle + Math.PI) % (2 * Math.PI);\n    arrow.setAttribute('d', arrow.getAttribute('d').match(PATH_START_REGEX)[0] + rotateLineElement(arrow, angle));\n    arrow.setAttribute('prev-angle', angle.toString());\n  } else {\n    arrow.setAttribute('d', \"M \".concat(p.x, \" \").concat(p.y, \" \") + getRestOfRegex(arrow));\n  }\n};\nvar removeWeights = function removeWeights(ids) {\n  ids.forEach(function (id) {\n    var weightItem = getWeightItemFromID(id);\n    var textItem = getWeightTextFromID(id);\n    if (weightItem !== null) {\n      weightItem.remove();\n    }\n    if (textItem !== null) {\n      textItem.remove();\n    }\n  });\n};\nvar getWeightData = function getWeightData(ids) {\n  var data = new Map();\n  ids.forEach(function (id) {\n    var weightInput = getWeightInputFromID(id);\n    if (weightInput !== null) {\n      data.set(id, weightInput.value === '' ? 0 : parseFloat(weightInput.value));\n    }\n  });\n  return data;\n};\nvar setWeightData = function setWeightData(data) {\n  data.forEach(function (weight, id) {\n    return getWeightTextFromID(id).textContent = \"\".concat(id, \";\").concat(weight);\n  });\n};\n\n// -------- RECONSTRUCT IMPORT SECTION -------- //\n// returns regex for provided name of the HTML element\nfunction getHTMLRegex(name) {\n  // regex must contain 'g', otherwise matchAll() won't work\n  // [^>] is considered a character class, it matches everything other than '>'\n  name = new RegExp(name.trim());\n  // return new RegExp(/<path[^>]*><\\/path>/g);\n  var result = concatRegExp(/</, name);\n  result = concatRegExp(result, /[^>]*>[^<]*<\\//);\n  result = concatRegExp(result, name);\n  return concatRegExp(result, />/g);\n}\n// different layers in canvas (edges, vertices, text)\nvar LAYER_COUNT = 3;\n// reconstruction of imported data\nvar recon = function recon(imported) {\n  imported = imported.replaceAll('&lt;', '<');\n  imported = imported.replaceAll('&gt;', '>');\n\n  // has to be updated if we decide to add something else in the future\n  var names = ['text', 'circle', 'polygon', 'rect', 'path'];\n  var hasInnerHTML = ['text', 'path'];\n  var regExps = names.map(function (name) {\n    return getHTMLRegex(name);\n  });\n  var items = [];\n  regExps.forEach(function (regex, i) {\n    var _iterator = _createForOfIteratorHelper(imported.matchAll(regex)),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var match = _step.value;\n        var name = '';\n        name = names[i]; // initialized like this to avoid editor warning\n\n        var customRegex = concatRegExp(new RegExp(/>[^<]*<\\//g), new RegExp(name + '>'));\n        var str = match[0].replace('<' + name + ' ', '').replace(customRegex, '') // ('><\\/' + name + '>', '') works only without value between ><\n        .replaceAll('\\\\\"', '\"');\n        var attrs = [];\n        var values = [];\n        // attributes are bounded by zero or one space and one quotation mark\n        var _iterator2 = _createForOfIteratorHelper(str.matchAll(/\\s?[^\"]*=/g)),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var attr = _step2.value;\n            attrs.push(attr[0].replaceAll(' ', '').replaceAll('=', ''));\n          }\n          // values are bounded by two quotation marks\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        var _iterator3 = _createForOfIteratorHelper(str.matchAll(/\"(.*?)\"/g)),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var value = _step3.value;\n            values.push(value[0].replaceAll('\\\"', ''));\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n        console.assert(attrs.length === values.length);\n        var item = document.createElementNS(SVG_NS_URI, name);\n        for (var j = 0; j < attrs.length; j++) {\n          item.setAttribute(attrs[j], values[j]);\n        }\n        if (hasInnerHTML.includes(item.tagName.toLowerCase())) {\n          item.innerHTML = match[0].match(/>[^<]*</)[0].replace('<', '').replace('>', '');\n        }\n        items.push(item);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  });\n  // items must be sorted properly: 1. edges (path), 2. vertices (circle, polygon, rect), 3. text\n  var temp = [];\n  for (var i = 0; i < LAYER_COUNT; i++) {\n    var arr = [];\n    temp.push(arr);\n  }\n  for (var _i3 = 0; _i3 < items.length; _i3++) {\n    var tagName = items[_i3].tagName.toLowerCase();\n    if (tagName === 'path') {\n      temp[0].push(items[_i3]); // layer 1\n    } else if (['circle', 'polygon', 'rect'].includes(tagName)) {\n      temp[1].push(items[_i3]); // layer 2\n    } else {\n      console.assert(tagName === 'text');\n      temp[2].push(items[_i3]); // layer 3\n    }\n  }\n\n  items = [];\n  temp.forEach(function (arr) {\n    return arr.forEach(function (el) {\n      return items.push(el);\n    });\n  });\n  return items;\n};\n// -------------------------------------------- //\n/**\r\n * shrink vertex and save its original look before shrinking, so it can be\r\n * returned to the original state in the expand function, hide text\r\n * @param vertexObj\r\n * @param r\r\n * @returns {{}}\r\n */\nvar shrink = function shrink(vertexObj, r) {\n  var id = vertexObj.id;\n  getTextFromID(id).style.visibility = 'hidden';\n  var vertex = getVertexFromID(id);\n  var name = vertex.tagName.toLowerCase();\n  var originalLook = {};\n  switch (name) {\n    case 'circle':\n      originalLook['r'] = vertex.getAttribute('r');\n      vertex.setAttribute('r', r.toString());\n      break;\n    case 'rect':\n      originalLook['width'] = vertex.getAttribute('width');\n      originalLook['height'] = vertex.getAttribute('height');\n      var ratio = parseFloat(originalLook['width']) / parseFloat(originalLook['height']);\n      vertex.setAttribute('width', r.toString());\n      vertex.setAttribute('height', \"\".concat(r / ratio));\n      break;\n    case 'polygon':\n      originalLook['polygon-base'] = vertex.getAttribute('polygon-base');\n      originalLook['points'] = vertex.getAttribute('points');\n      var a = r.toString();\n      var n = parseFloat(vertex.getAttribute('number-of-angles'));\n      var x = 0,\n        y = 0;\n      originalLook['points'].trim().split(' ').forEach(function (point) {\n        point = point.split(',');\n        x += parseFloat(point[0]);\n        y += parseFloat(point[1]);\n      });\n      x /= n;\n      y /= n;\n      vertexObj.SVG['polygon-base'] = a;\n      vertex.setAttribute('polygon-base', a);\n      vertex.setAttribute('points', vertexObj.SVG['points'] = findPolygonPoints(x, y, a, n));\n      break;\n  }\n  return originalLook;\n};\n\n/**\r\n * restore vertex's look before shrinking, make text visible again\r\n * @param originalLookMap\r\n */\nvar expand = function expand(originalLookMap) {\n  originalLookMap.forEach(function (originalLook, vertexObj) {\n    var attrs = Object.keys(originalLook);\n    var values = Object.values(originalLook);\n    console.assert(attrs.length === values.length);\n    var vertex = getVertexFromID(vertexObj.id);\n    var text = getTextFromID(vertexObj.id);\n    for (var i = 0; i < attrs.length; i++) {\n      // update object's SVG attribute\n      vertexObj.SVG[\"\".concat(attrs[i])] = values[i];\n      // update SVG itself\n      vertex.setAttribute(\"\".concat(attrs[i]), values[i].toString());\n    }\n    text.style.visibility = 'visible';\n  });\n};\nvar createFace = function createFace(polygon, vertices, fill) {\n  var points = polygon.map(function (coordinates) {\n    return coordinates.join(',');\n  }).join(' ');\n  var face = document.createElementNS(SVG_NS_URI, 'polygon');\n  face.setAttribute('class', 'face');\n  face.setAttribute('fill', fill);\n  face.setAttribute('points', points);\n  face.setAttribute('vertices', vertices.join(','));\n  return face;\n};\nvar restore = function restore(elements) {\n  if (elements !== null && elements !== undefined) {\n    elements.forEach(function (el) {\n      SVG_CANVAS.removeChild(el);\n      SVG_CANVAS.appendChild(el);\n    });\n  }\n};\nvar restoreAll = function restoreAll() {\n  restore(getAllEdges());\n  restore(getAllArrows());\n  restore(getAllWeightItems());\n  restore(getAllWeightTexts());\n  restore(getAllVertices());\n  restore(getAllTexts());\n};\nvar toggleButtonsExcept = function toggleButtonsExcept(affectedButtons, nonAffectedButtons) {\n  var diff = _.difference(affectedButtons, nonAffectedButtons);\n  var activate = function activate() {\n    return diff.forEach(function (btn) {\n      return setClickable(btn);\n    });\n  };\n  var deactivate = function deactivate() {\n    return diff.forEach(function (btn) {\n      return setNonClickable(btn);\n    });\n  };\n  return {\n    activate: activate,\n    deactivate: deactivate\n  };\n};\n\n\n//# sourceURL=webpack://test_zav/./public/scripts/models/DrawingHelperModel.js?");

/***/ }),

/***/ "./public/scripts/models/EdgeModel.js":
/*!********************************************!*\
  !*** ./public/scripts/models/EdgeModel.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Edge\": () => (/* binding */ Edge),\n/* harmony export */   \"Type\": () => (/* binding */ Type)\n/* harmony export */ });\n/* harmony import */ var _ClientDefaultsModel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ClientDefaultsModel.js */ \"./public/scripts/models/ClientDefaultsModel.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nvar Type = {\n  UNDIRECTED_LINE: 1,\n  UNDIRECTED_LOOP: 2,\n  DIRECTED_LINE: 3,\n  DIRECTED_LOOP: 4\n};\nObject.freeze(Type);\nvar Edge = /*#__PURE__*/function () {\n  // transferred from edgeIdCounter (VertexModel.js) -> drawing.js -> here\n  // list of ids of adjacent edges\n  // EdgeType value\n  // non-negative integer (undefined if isWeighted is false)\n  // boolean\n  // ids of vertices that are connected by this edge\n  // contains custom attributes used in drawing.js\n\n  function Edge(id, type, isWeighted, connection) {\n    _classCallCheck(this, Edge);\n    _defineProperty(this, \"id\", void 0);\n    _defineProperty(this, \"adjacent\", void 0);\n    _defineProperty(this, \"type\", void 0);\n    _defineProperty(this, \"weight\", void 0);\n    _defineProperty(this, \"isWeighted\", void 0);\n    _defineProperty(this, \"connection\", void 0);\n    _defineProperty(this, \"helper\", void 0);\n    // option for empty constructor (we can't have multiple constructors in js)\n    if (id === undefined && type === undefined && isWeighted === undefined && connection === undefined) return this;\n    this.id = id;\n    this.adjacent = [];\n    this.type = type;\n    this.isWeighted = isWeighted;\n    this.connection = connection;\n    this.helper = {};\n  }\n  _createClass(Edge, [{\n    key: \"setWeight\",\n    value: function setWeight(weight) {\n      if (this.isWeighted === true) {\n        this.weight = weight;\n      } else {\n        throw 'Setting weight to unweighted edge is forbidden!';\n      }\n    }\n  }, {\n    key: \"addAdjacent\",\n    value: function addAdjacent(arr) {\n      this.adjacent.push(arr);\n    }\n  }], [{\n    key: \"initEdgeSVG\",\n    value: function initEdgeSVG() {\n      var saveEdgeBtn = document.querySelector('#save-edge');\n      var event = new MouseEvent('click', _ClientDefaultsModel_js__WEBPACK_IMPORTED_MODULE_0__.clickOptions);\n      saveEdgeBtn.dispatchEvent(event);\n      return this.updateEdgeSVG();\n    }\n  }, {\n    key: \"updateEdgeSVG\",\n    value: function updateEdgeSVG() {\n      var formData = new FormData(document.querySelector('#edge-properties form'));\n      var shape = formData.get('select-edge-shape').toLowerCase();\n      this.edgeSVG = _objectSpread(_objectSpread({}, shape === 'line' && {\n        'shape': 'path'\n      }), {}, {\n        'stroke': formData.get('edge-border').toString(),\n        'stroke-width': formData.get('edge-width'),\n        'scale-loop': formData.get('scale-loop')\n      });\n      var request = new Request('/edge', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(this.edgeSVG)\n      });\n      // async function\n      fetch(request).then();\n      return this.edgeSVG;\n    }\n  }]);\n  return Edge;\n}();\n_defineProperty(Edge, \"edgeSVG\", void 0);\n\n\n//# sourceURL=webpack://test_zav/./public/scripts/models/EdgeModel.js?");

/***/ }),

/***/ "./public/scripts/models/FaceTrackerModel.js":
/*!***************************************************!*\
  !*** ./public/scripts/models/FaceTrackerModel.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FaceTracker)\n/* harmony export */ });\n/* harmony import */ var _DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DrawingHelperModel.js */ \"./public/scripts/models/DrawingHelperModel.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nvar FaceTracker = /*#__PURE__*/function () {\n  function FaceTracker() {\n    _classCallCheck(this, FaceTracker);\n  }\n  _createClass(FaceTracker, null, [{\n    key: \"init\",\n    value: function init() {\n      VERTEX_OBSERVER.observe(SVG_CANVAS, {\n        childList: true\n      });\n    }\n  }]);\n  return FaceTracker;\n}();\n\nvar FACE_OBSERVER = new MutationObserver(function (mutations) {\n  var faces = (0,_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_0__.getAll)('polygon.face');\n  if (faces === null) {\n    return;\n  }\n  var _iterator = _createForOfIteratorHelper(mutations),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var mutation = _step.value;\n      var id = (0,_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_0__.getIDFromVertex)(mutation.target);\n      var _iterator2 = _createForOfIteratorHelper(faces),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var face = _step2.value;\n          var vertices = face.getAttribute('vertices').split(',').map(function (id) {\n            return parseInt(id);\n          });\n          var index = vertices.indexOf(id);\n          if (index === -1) {\n            continue;\n          }\n          var points = face.getAttribute('points').split(' ');\n          var x = void 0,\n            y = void 0;\n          if (mutation.attributeName === 'CA-center-x') {\n            x = mutation.target.getAttribute('CA-center-x');\n            y = points[index].split(',')[1];\n          } else {\n            x = points[index].split(',')[0];\n            y = mutation.target.getAttribute('CA-center-y');\n          }\n          points[index] = x + ',' + y;\n          face.setAttribute('points', points.join(' '));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n});\nvar VERTEX_OBSERVER = new MutationObserver(function (mutations) {\n  var _iterator3 = _createForOfIteratorHelper(mutations),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var mutation = _step3.value;\n      var _iterator4 = _createForOfIteratorHelper(mutation.addedNodes),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var added = _step4.value;\n          if (added.id.startsWith('vertex-id-')) {\n            FACE_OBSERVER.observe(added, {\n              attributes: true,\n              attributeFilter: ['CA-center-x', 'CA-center-y']\n            });\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n});\n\n//# sourceURL=webpack://test_zav/./public/scripts/models/FaceTrackerModel.js?");

/***/ }),

/***/ "./public/scripts/models/JSONExtensionModel.js":
/*!*****************************************************!*\
  !*** ./public/scripts/models/JSONExtensionModel.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"replacer\": () => (/* binding */ replacer),\n/* harmony export */   \"reviver\": () => (/* binding */ reviver)\n/* harmony export */ });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n// source: https://stackoverflow.com/questions/29085197/how-do-you-json-stringify-an-es6-map\n// these functions are enabling JSON.stringify() and JSON.parse() to work with Map objects\n// second argument for JSON.stringify()\nfunction replacer(key, value) {\n  if (value instanceof Map) {\n    return {\n      dataType: 'Map',\n      value: Array.from(value.entries()) // or with spread: value: [...value]\n    };\n  }\n\n  return value;\n}\n\n// second argument for JSON.parse()\nfunction reviver(key, value) {\n  if (_typeof(value) === 'object' && value !== null) {\n    if (value.dataType === 'Map') {\n      return new Map(value.value);\n    }\n  }\n  return value;\n}\n\n\n//# sourceURL=webpack://test_zav/./public/scripts/models/JSONExtensionModel.js?");

/***/ }),

/***/ "./public/scripts/models/ScreenshotModel.js":
/*!**************************************************!*\
  !*** ./public/scripts/models/ScreenshotModel.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScreenshotManager\": () => (/* binding */ ScreenshotManager)\n/* harmony export */ });\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar FORMATS = Object.freeze(['webp', 'png', 'jpeg', 'bmp', 'ico', 'gif', 'pdf']);\nvar PDFTracker = /*#__PURE__*/function () {\n  function PDFTracker(pdf, savePDFAdded, pointerEvents) {\n    _classCallCheck(this, PDFTracker);\n    this._pdf = pdf;\n    this._savePDFAdded = savePDFAdded;\n    this._pointerEvents = pointerEvents;\n\n    // savePDF won't work properly within the event listeners without binding\n    // because attributes will be undefined\n    this.savePDF = this.savePDF.bind(this);\n  }\n  _createClass(PDFTracker, [{\n    key: \"savePDF\",\n    value: function savePDF() {\n      this._pdf.save('screenshot.pdf'); // downloads a PDF file\n    }\n  }, {\n    key: \"pdf\",\n    get: function get() {\n      return this._pdf;\n    },\n    set: function set(value) {\n      this._pdf = value;\n    }\n  }, {\n    key: \"savePDFAdded\",\n    get: function get() {\n      return this._savePDFAdded;\n    },\n    set: function set(value) {\n      this._savePDFAdded = value;\n    }\n  }, {\n    key: \"pointerEvents\",\n    get: function get() {\n      return this._pointerEvents;\n    },\n    set: function set(value) {\n      this._pointerEvents = value;\n    }\n  }]);\n  return PDFTracker;\n}();\nvar Image = /*#__PURE__*/function () {\n  function Image(data, w, h) {\n    _classCallCheck(this, Image);\n    this._data = data;\n    this._w = w;\n    this._h = h;\n  }\n  _createClass(Image, [{\n    key: \"data\",\n    get: function get() {\n      return this._data;\n    },\n    set: function set(value) {\n      this._data = value;\n    }\n  }, {\n    key: \"w\",\n    get: function get() {\n      return this._w;\n    },\n    set: function set(value) {\n      this._w = value;\n    }\n  }, {\n    key: \"h\",\n    get: function get() {\n      return this._h;\n    },\n    set: function set(value) {\n      this._h = value;\n    }\n  }]);\n  return Image;\n}();\nvar ScreenshotManager = /*#__PURE__*/function () {\n  function ScreenshotManager() {\n    _classCallCheck(this, ScreenshotManager);\n    this.div = document.querySelector('#screenshot-div');\n    this.select = document.querySelector('#select-screenshot-format');\n    this.link = document.querySelector('#export-screenshot-link');\n    this.download = document.querySelector('#download-screenshot-button');\n    this.cancel = document.querySelector('#cancel-screenshot-button');\n    this.initDownload();\n    this.initCancel();\n    this.initScreenshotFrame();\n    this.initSelect();\n    this.tracker = new PDFTracker(null, false, this.link.style.pointerEvents);\n  }\n  _createClass(ScreenshotManager, [{\n    key: \"initScreenshotFrame\",\n    value: function initScreenshotFrame() {\n      this.rect = document.createElementNS(SVG_NS_URI, 'rect');\n      this.rect.setAttribute('id', 'screenshot-rect');\n      this.rect.setAttribute('stroke', '#1c0952');\n      this.rect.setAttribute('stroke-width', '2');\n      this.rect.setAttribute('fill', 'white');\n      this.rect.setAttribute('fill-opacity', '0.25');\n    }\n  }, {\n    key: \"initDownload\",\n    value: function initDownload() {\n      var _this = this;\n      this.download.addEventListener('click', function () {\n        setInvisible(_this.div);\n      });\n    }\n  }, {\n    key: \"initCancel\",\n    value: function initCancel() {\n      var _this2 = this;\n      this.cancel.addEventListener('click', function () {\n        setInvisible(_this2.div);\n      });\n    }\n  }, {\n    key: \"initSelect\",\n    value: function initSelect() {\n      var _this3 = this;\n      this.select.addEventListener('change', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _this3.rect.setAttribute('stroke', 'none');\n              _this3.rect.setAttribute('fill', 'none');\n              SVG_CANVAS.appendChild(_this3.rect);\n              _context.next = 5;\n              return _this3.downloadScreenshot();\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      })));\n    }\n\n    /**\r\n     * user must mark the whole SVG element such as vertex, edge, etc.,\r\n     * otherwise image won't be rendered properly\r\n     * @returns {Promise<unknown>}\r\n     */\n  }, {\n    key: \"takeScreenshot\",\n    value: function () {\n      var _takeScreenshot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _this4 = this;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.abrupt(\"return\", new Promise(function (resolve) {\n                var mousedown = function mousedown(e) {\n                  SVG_CANVAS.addEventListener('mouseup', mouseup);\n                  _this4.startScreenshotRect(e);\n                  SVG_CANVAS.addEventListener('mousemove', mousemove);\n                };\n                var mousemove = function mousemove(e) {\n                  return _this4.continueScreenshotRect(e);\n                };\n                var mouseup = function mouseup() {\n                  SVG_CANVAS.removeEventListener('mousemove', mousemove);\n                  SVG_CANVAS.removeEventListener('mouseup', mouseup);\n                  SVG_CANVAS.removeEventListener('mousedown', mousedown);\n                  SVG_CANVAS.style.cursor = 'default';\n                  setVisible(_this4.div);\n\n                  // rect won't be the part of the screenshot\n                  _this4.rect.setAttribute('stroke', 'none');\n                  _this4.rect.setAttribute('fill', 'none');\n                  _this4.downloadScreenshot();\n                  resolve();\n                };\n                SVG_CANVAS.addEventListener('mousedown', mousedown);\n                SVG_CANVAS.style.cursor = 'crosshair';\n              }));\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n      function takeScreenshot() {\n        return _takeScreenshot.apply(this, arguments);\n      }\n      return takeScreenshot;\n    }()\n  }, {\n    key: \"getCoordinates\",\n    value: function getCoordinates(e) {\n      return [e.clientX - SVG_CANVAS_BOUNDS.left, e.clientY - SVG_CANVAS_BOUNDS.top];\n    }\n  }, {\n    key: \"startScreenshotRect\",\n    value: function startScreenshotRect(e) {\n      var _this$getCoordinates = this.getCoordinates(e),\n        _this$getCoordinates2 = _slicedToArray(_this$getCoordinates, 2),\n        x = _this$getCoordinates2[0],\n        y = _this$getCoordinates2[1];\n      this.rect.setAttribute('x', x.toString());\n      this.rect.setAttribute('y', y.toString());\n      this.rect.setAttribute('width', '0');\n      this.rect.setAttribute('height', '0');\n      SVG_CANVAS.appendChild(this.rect);\n      this.x0 = x;\n      this.y0 = y;\n    }\n  }, {\n    key: \"continueScreenshotRect\",\n    value: function continueScreenshotRect(e) {\n      var _this$getCoordinates3 = this.getCoordinates(e),\n        _this$getCoordinates4 = _slicedToArray(_this$getCoordinates3, 2),\n        x = _this$getCoordinates4[0],\n        y = _this$getCoordinates4[1];\n      var w = Math.abs(x - this.x0);\n      var h = Math.abs(y - this.y0);\n      this.rect.setAttribute('x', Math.min(this.x0, x).toString());\n      this.rect.setAttribute('y', Math.min(this.y0, y).toString());\n      this.rect.setAttribute('width', w.toString());\n      this.rect.setAttribute('height', h.toString());\n    }\n\n    /**\r\n     * selects SVG element and encodes its content in base64 encoding,\r\n     * sets the information about dimensions and size\r\n     * supported formats are: webp, png, jpeg, bmp, ico, gif\r\n     * @returns {Promise<void>}\r\n     * @throws Invalid image format! if the format is wrong\r\n     */\n  }, {\n    key: \"downloadScreenshot\",\n    value: function () {\n      var _downloadScreenshot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var _this5 = this;\n        var format, xml, svg64, b64Start, image64;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              format = this.select.value.toLowerCase();\n              if (FORMATS.includes(format)) {\n                _context3.next = 3;\n                break;\n              }\n              throw 'Invalid image format!';\n            case 3:\n              // xml: https://stackoverflow.com/questions/3768565/drawing-an-svg-file-on-a-html5-canvas\n              // convert: https://stackoverflow.com/questions/3975499/convert-svg-to-image-jpeg-png-etc-in-the-browser\n              xml = new XMLSerializer().serializeToString(SVG_CANVAS);\n              svg64 = btoa(xml);\n              b64Start = 'data:image/svg+xml;base64,';\n              image64 = b64Start + svg64;\n              this.tracker.pdf = null;\n              if (format === 'pdf') {\n                // if provided format is PDF, PNG will be created first,\n                // and then it will be converted in PDF\n                format = 'png';\n                // specifying A4 size and using millimetres as a measurement unit\n                this.tracker.pdf = new jspdf.jsPDF('portrait', 'mm', 'a4');\n              }\n              this.base64SvgToBase64Format(image64, format).then(function (img) {\n                _this5.setScreenshotInfo(img.data, img.w, img.h);\n                if (_this5.tracker.pdf !== null) {\n                  _this5.addPNGToPDF(_this5.tracker.pdf, img.data, img.w, img.h);\n                  _this5.link.style.pointerEvents = 'none';\n                  if (!_this5.tracker.savePDFAdded) {\n                    _this5.download.addEventListener('click', _this5.tracker.savePDF);\n                    _this5.tracker.savePDFAdded = true;\n                  }\n                } else {\n                  _this5.download.removeEventListener('click', _this5.tracker.savePDF);\n                  _this5.tracker.savePDFAdded = false;\n                  _this5.link.setAttribute('href', img.data.toString());\n                  _this5.link.setAttribute('download', 'screenshot.' + format);\n                  _this5.link.style.pointerEvents = _this5.tracker.pointerEvents;\n                }\n              })[\"catch\"](function (err) {\n                console.error(err);\n              }).then(function () {\n                SVG_CANVAS.removeChild(_this5.rect);\n                // reset default attributes for the next use\n                _this5.rect.setAttribute('stroke', '#1c0952');\n                _this5.rect.setAttribute('fill', 'white');\n              });\n            case 10:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function downloadScreenshot() {\n        return _downloadScreenshot.apply(this, arguments);\n      }\n      return downloadScreenshot;\n    }()\n    /**\r\n     * converts base64 encoded SVG to other specified format\r\n     * that is also encoded using base64\r\n     * @param originalBase64 original base64 string\r\n     * @param format image file extension\r\n     * @returns {Promise<unknown>} returns new encoding,\r\n     * otherwise returns 'Image conversion failed!'\r\n     */\n  }, {\n    key: \"base64SvgToBase64Format\",\n    value: function base64SvgToBase64Format(originalBase64, format) {\n      var img = document.createElement('img');\n      var rect = this.rect;\n      return new Promise(function (resolve, reject) {\n        img.onload = function () {\n          var canvas = document.createElement('canvas');\n          var context = canvas.getContext('2d');\n          var bounds = rect.getBoundingClientRect();\n\n          // new dimensions are set to double size to avoid the blurry image\n          canvas.width = bounds.width * 2;\n          canvas.height = bounds.height * 2;\n          canvas.style.width = '100%';\n          canvas.style.height = '100%';\n          var sx = bounds.left - SVG_CANVAS_BOUNDS.left;\n          var sy = bounds.top - SVG_CANVAS_BOUNDS.top;\n          var sw = bounds.width;\n          var sh = bounds.height;\n          var dx = 0;\n          var dy = 0;\n          var dw = bounds.width * 2;\n          var dh = bounds.height * 2;\n          context.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);\n          try {\n            var data = canvas.toDataURL('image/' + format, 1);\n            resolve(new Image(data, dw, dh));\n          } catch (e) {\n            reject('Image conversion failed!');\n          }\n        };\n        img.onerror = function () {\n          return reject('Image conversion failed!');\n        };\n        img.src = originalBase64;\n      });\n    }\n  }, {\n    key: \"addPNGToPDF\",\n    value: function addPNGToPDF(pdf, imgData, imgW, imgH) {\n      // The A4 page size is 210 mm x 297 mm.\n      var pageW = 210;\n      var pageH = 297;\n      var scale = imgW > pageW || imgH > pageH ? Math.min(pageW / imgW, pageH / imgH) : 1;\n      pdf.addImage(imgData, 'PNG', 0, 0, imgW * scale, imgH * scale);\n    }\n  }, {\n    key: \"setScreenshotInfo\",\n    value: function setScreenshotInfo(imgData, imgW, imgH) {\n      // https://blog.aaronlenoir.com/2017/11/10/get-original-length-from-base-64-string/\n      // base64 uses 4 ascii characters to encode 24-bits (3 bytes) of data.\n      var content = imgData.toString().split('base64,')[1];\n      var bytes = new TextEncoder().encode(content).length * 3 / 4;\n      document.querySelector('#screenshot-width').innerHTML = Math.round(imgW).toString();\n      document.querySelector('#screenshot-height').innerHTML = Math.round(imgH).toString();\n      document.querySelector('#screenshot-size').innerHTML = (bytes / 1024).toFixed(2).toString();\n    }\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance() {\n      return ScreenshotManager.instance;\n    }\n  }]);\n  return ScreenshotManager;\n}();\n_defineProperty(ScreenshotManager, \"instance\", new ScreenshotManager());\n\n\n//# sourceURL=webpack://test_zav/./public/scripts/models/ScreenshotModel.js?");

/***/ }),

/***/ "./public/scripts/models/ToolEnumModel.js":
/*!************************************************!*\
  !*** ./public/scripts/models/ToolEnumModel.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Tool\": () => (/* binding */ Tool),\n/* harmony export */   \"toolActive\": () => (/* binding */ toolActive)\n/* harmony export */ });\nvar Tool = {\n  UNDEFINED: 0,\n  DRAW_VERTEX: 1,\n  DRAW_EDGE: 2,\n  MOVE: 3,\n  ROTATE: 4,\n  CLEAR: 5,\n  DELETE: 6,\n  DIRECTION: 7,\n  WEIGHT: 8,\n  SHRINK: 9,\n  EXPAND: 10,\n  SCREENSHOT: 11,\n  SKETCH: 12,\n  COLOR: 13\n};\nObject.freeze(Tool);\n// simulating enumeration in javascript by freezing an object\n// because it isn't supported natively\n\n// source: https://stackoverflow.com/questions/1759987/listening-for-variable-changes-in-javascript\n// listening for a variable to change in order to make code more readable and less redundant\nvar toolActive = {\n  currentInternal: 0,\n  // default values\n  previousInternal: null,\n  currentListener: function currentListener(val) {},\n  set current(val) {\n    this.previousInternal = this.currentInternal;\n    this.currentInternal = val;\n    this.currentListener(val);\n  },\n  get current() {\n    return this.currentInternal;\n  },\n  get previous() {\n    return this.previousInternal;\n  },\n  registerListener: function registerListener(listener) {\n    this.currentListener = listener;\n  }\n};\n\n\n//# sourceURL=webpack://test_zav/./public/scripts/models/ToolEnumModel.js?");

/***/ }),

/***/ "./public/scripts/models/VertexModel.js":
/*!**********************************************!*\
  !*** ./public/scripts/models/VertexModel.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CIRCLE_SIZE\": () => (/* binding */ CIRCLE_SIZE),\n/* harmony export */   \"START_EDGE_ID_COUNTER\": () => (/* binding */ START_EDGE_ID_COUNTER),\n/* harmony export */   \"START_VERTEX_ID_COUNTER\": () => (/* binding */ START_VERTEX_ID_COUNTER),\n/* harmony export */   \"TEXT_Y_OFFSET\": () => (/* binding */ TEXT_Y_OFFSET),\n/* harmony export */   \"Vertex\": () => (/* binding */ Vertex),\n/* harmony export */   \"addToEdgeIDCounter\": () => (/* binding */ addToEdgeIDCounter),\n/* harmony export */   \"addToVertexIDCounter\": () => (/* binding */ addToVertexIDCounter),\n/* harmony export */   \"createEdge\": () => (/* binding */ createEdge),\n/* harmony export */   \"edgeIDCounter\": () => (/* binding */ edgeIDCounter),\n/* harmony export */   \"getArrowBody\": () => (/* binding */ getArrowBody),\n/* harmony export */   \"getArrowForLine\": () => (/* binding */ getArrowForLine),\n/* harmony export */   \"getArrowForLoop\": () => (/* binding */ getArrowForLoop),\n/* harmony export */   \"getIDCounters\": () => (/* binding */ getIDCounters),\n/* harmony export */   \"getUndirectedArc\": () => (/* binding */ getUndirectedArc),\n/* harmony export */   \"getUndirectedLine\": () => (/* binding */ getUndirectedLine),\n/* harmony export */   \"getUndirectedLoop\": () => (/* binding */ getUndirectedLoop),\n/* harmony export */   \"restore\": () => (/* binding */ restore),\n/* harmony export */   \"setIDCounters\": () => (/* binding */ setIDCounters),\n/* harmony export */   \"vertexIDCounter\": () => (/* binding */ vertexIDCounter)\n/* harmony export */ });\n/* harmony import */ var _models_ClientDefaultsModel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/ClientDefaultsModel.js */ \"./public/scripts/models/ClientDefaultsModel.js\");\n/* harmony import */ var _DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DrawingHelperModel.js */ \"./public/scripts/models/DrawingHelperModel.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\nvar START_VERTEX_ID_COUNTER = 1;\nvar START_EDGE_ID_COUNTER = 1;\nvar vertexIDCounter = START_VERTEX_ID_COUNTER;\nvar edgeIDCounter = START_EDGE_ID_COUNTER;\n// SVG namespace - needed for creating SVG elements dynamically\nvar TEXT_Y_OFFSET = 1.975;\nvar CIRCLE_SIZE = 75;\nvar ARC_SPACING = 75;\nfunction getIDCounters() {\n  return [vertexIDCounter, edgeIDCounter];\n}\nfunction setIDCounters(arr) {\n  vertexIDCounter = arr[0];\n  edgeIDCounter = arr[1];\n}\n\n/**\r\n * neighbours - array which contains id's of all neighbour vertices\r\n * SVG - array which contains SVG properties\r\n */\nvar Vertex = /*#__PURE__*/function () {\n  function Vertex(x, y, SVG) {\n    _classCallCheck(this, Vertex);\n    _defineProperty(this, \"id\", void 0);\n    _defineProperty(this, \"neighbours\", void 0);\n    _defineProperty(this, \"x\", void 0);\n    _defineProperty(this, \"y\", void 0);\n    _defineProperty(this, \"SVG\", void 0);\n    _defineProperty(this, \"shape\", void 0);\n    _defineProperty(this, \"helper\", void 0);\n    // option for empty constructor (we can't have multiple constructors in js)\n    if (x === undefined && y === undefined && SVG === undefined) return this;\n    this.id = vertexIDCounter++;\n    this.neighbours = [];\n    this.x = x;\n    this.y = y;\n    if (SVG.shape === 'triangle') {\n      this.shape = 'polygon';\n    } else if (SVG.shape === 'square' || SVG.shape === 'rectangle') {\n      this.shape = 'rect';\n    } else {\n      this.shape = SVG.shape;\n    }\n    this.SVG = SVG;\n    this.SVG['id'] = \"vertex-id-\".concat(this.id);\n    this.helper = {};\n  }\n\n  /**\r\n   * Creates vertex of specified shape as SVG element.\r\n   * @returns {*}\r\n   */\n  _createClass(Vertex, [{\n    key: \"createVertex\",\n    value: function createVertex() {\n      var vertex = document.createElementNS(SVG_NS_URI, this.shape);\n      for (var _i = 0, _Object$entries = Object.entries(this.SVG); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n          key = _Object$entries$_i[0],\n          value = _Object$entries$_i[1];\n        vertex.setAttribute(\"\".concat(key), \"\".concat(value));\n      }\n      // set custom attributes CA-center-x and CA-center-y\n      vertex.setAttribute('CA-center-x', \"\".concat(this.x));\n      vertex.setAttribute('CA-center-y', \"\".concat(this.y));\n      return vertex;\n    }\n  }, {\n    key: \"addText\",\n    value: function addText() {\n      var text = document.createElementNS(SVG_NS_URI, \"text\");\n      // font-weight = {normal | bold | bolder | lighter}\n      // dominant-baseline = middle -> center vertically\n      // text-anchor = middle -> center horizontally\n      // pointer-events = none -> make SVGText elements not clickable\n      var props = [\"id\", \"x\", \"y\", \"dominant-baseline\", \"text-anchor\", \"font-size\", \"font-weight\", \"fill\", \"pointer-events\"];\n      // added custom offset to y-axis because numbers are taking middle and upper part of the line\n      // ex. letter j is taking middle and lower part in SVG\n      var propsValues = [\"text-id-\".concat(this.id), \"\".concat(this.x), \"\".concat(this.y + TEXT_Y_OFFSET), \"middle\", \"middle\", \"15px\", \"normal\", \"white\", \"none\"];\n      for (var i = 0; i < props.length; i++) {\n        text.setAttribute(props[i], propsValues[i]);\n      }\n      text.style.userSelect = 'none';\n      text.textContent = \"\".concat(this.id);\n      return text;\n    }\n  }], [{\n    key: \"initVertexSVG\",\n    value: function initVertexSVG() {\n      var saveVertexBtn = document.querySelector('#save-vertex');\n      var event = new MouseEvent('click', _models_ClientDefaultsModel_js__WEBPACK_IMPORTED_MODULE_0__.clickOptions);\n      saveVertexBtn.dispatchEvent(event);\n      return this.updateVertexSVG();\n    }\n  }, {\n    key: \"updateVertexSVG\",\n    value: function updateVertexSVG() {\n      var formData = new FormData(document.querySelector('#vertex-properties form'));\n      var shape = formData.get('select-vertex-shape').toLowerCase();\n      this.vertexSVG = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({\n        'shape': shape,\n        'fill': formData.get('vertex-fill'),\n        'stroke': formData.get('vertex-border'),\n        'stroke-width': formData.get('vertex-border-width')\n      }, shape === 'circle' && {\n        'r': formData.get('circle-radius')\n      }), shape === 'square' && {\n        'width': formData.get('square-base'),\n        'height': formData.get('square-base')\n      }), shape === 'rectangle' && {\n        'width': formData.get('rectangle-width'),\n        'height': formData.get('rectangle-height')\n      }), shape === 'triangle' && {\n        'polygon-base': formData.get('triangle-base'),\n        'number-of-angles': '3',\n        'fill-rule': 'nonzero' // available only to polygons (like triangle)\n      }), shape === 'polygon' && {\n        'polygon-base': formData.get('polygon-base'),\n        'number-of-angles': formData.get('number-of-angles'),\n        'fill-rule': 'nonzero'\n      });\n      var request = new Request('/vertex', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(this.vertexSVG)\n      });\n      // async function\n      fetch(request).then();\n      return this.vertexSVG;\n    }\n  }]);\n  return Vertex;\n}();\n/**\r\n * returns string for creating loop for undirected graph\r\n * @param x - vertex center x-axis coordinate\r\n * @param y - vertex center y-axis coordinate\r\n * @param scaleLoop - factor for scaling size of the loop\r\n * @param circleSize - it must be multiplied by scaleLoop before calling method\r\n * @returns {*}\r\n */\n_defineProperty(Vertex, \"vertexSVG\", void 0);\nvar getUndirectedLoop = function getUndirectedLoop(x, y, scaleLoop, circleSize) {\n  return \"M \".concat(x, \" \").concat(y, \" \") + \"a 400 400 0 0 1 \".concat(-75 * scaleLoop, \" \").concat(-200 * scaleLoop, \" \") + \"a \".concat(circleSize, \" \").concat(circleSize, \" 0 0 1 \").concat(circleSize, \" -\").concat(circleSize, \" \") + \"a \".concat(circleSize, \" \").concat(circleSize, \" 0 0 1 \").concat(circleSize, \" \").concat(circleSize, \" \") + \"a 400 400 0 0 1 \".concat(-75 * scaleLoop, \" \").concat(200 * scaleLoop);\n};\n\n/**\r\n * returns string for creating straight edge for undirected graph\r\n * @param x1 - 1st vertex center x-axis coordinate\r\n * @param y1 - 1st vertex center y-axis coordinate\r\n * @param x2 - 2nd vertex center x-axis coordinate\r\n * @param y2 - 2nd vertex center y-axis coordinate\r\n * @returns {`M ${string} ${string} l ${string} ${string}`}\r\n */\nvar getUndirectedLine = function getUndirectedLine(x1, y1, x2, y2) {\n  return \"M \".concat(x1, \" \").concat(y1, \" l \").concat(x2, \" \").concat(y2);\n};\nvar getUndirectedArc = function getUndirectedArc(x1, y1, x2, y2, h, inv) {\n  // midpoint and slope formulas are different from the standard\n  // ones because (x2, y2) is relative to (x1, y1)\n  var xp = x1 + x2 / 2;\n  var yp = y1 + y2 / 2;\n  var k = -x2 / y2;\n  var xc, yc;\n  if (inv) {\n    h = -h;\n  }\n  if (k === Number.POSITIVE_INFINITY) {\n    xc = xp;\n    yc = yp - h;\n  } else if (k === Number.NEGATIVE_INFINITY) {\n    xc = xp;\n    yc = yp + h;\n  } else if (Object.is(k, 0)) {\n    xc = xp + h;\n    yc = yp;\n  } else if (Object.is(k, -0)) {\n    xc = xp - h;\n    yc = yp;\n  } else {\n    var l = yp - k * xp;\n    var a = 1 + Math.pow(k, 2);\n    var b = -2 * xp + 2 * k * (l - yp);\n    var c = Math.pow(xp, 2) + Math.pow(l - yp, 2) - Math.pow(h, 2);\n    var root = Math.sqrt(Math.pow(b, 2) - 4 * a * c);\n    xc = x2 > 0 && y2 < 0 || x2 < 0 && y2 < 0 ? -b + root : -b - root; // 3rd and 4th quadrant\n\n    var xc1 = -b + root;\n    var xc2 = -b - root;\n    if (xc === xc1) {\n      if (inv) {\n        xc = xc2;\n      }\n    } else {\n      if (inv) {\n        xc = xc1;\n      }\n    }\n    xc /= 2 * a;\n    yc = k * xc + l;\n  }\n  return \"M \".concat(x1, \" \").concat(y1, \" q \").concat(xc - x1, \" \").concat(yc - y1, \" \").concat(x2, \" \").concat(y2);\n};\n\n/**\r\n * returns string for creating body of an arrow, only starting position is\r\n * different between directed loop and directed line because coordinates\r\n * in getArrowBody are relative to starting ones\r\n * @param scaleArrow\r\n * @returns {*}\r\n */\nvar getArrowBody = function getArrowBody(scaleArrow) {\n  return \"l \".concat(-14 * scaleArrow, \" \", 0, \" \") + \"l \".concat(25 * scaleArrow, \" \").concat(-12.5 * scaleArrow, \" \") + \"l \".concat(-5 * scaleArrow, \" \").concat(12.5 * scaleArrow, \" \") + \"l \".concat(5 * scaleArrow, \" \").concat(12.5 * scaleArrow, \" \") + \"l \".concat(-25 * scaleArrow, \" \").concat(-12.5 * scaleArrow);\n};\n\n/**\r\n * returns string for creating loop for directed graph (with arrow),\r\n * everything else than scaleArrow works the same as in getUndirectedLoop\r\n * scaleArrow - factor for scaling size of the arrow\r\n */\nvar getArrowForLoop = function getArrowForLoop(id, x, y, edgeSVG, scaleArrow) {\n  var scaleLoop = edgeSVG['scale-loop'],\n    circleSize = scaleLoop * CIRCLE_SIZE;\n  var arrow = document.createElementNS(SVG_NS_URI, 'path');\n  arrow.setAttribute('id', \"arrow-id-\".concat(id));\n  arrow.setAttribute('fill', edgeSVG['stroke']);\n  var centerX = x - 75 * scaleLoop + circleSize;\n  var centerY = y - 200 * scaleLoop - circleSize;\n  arrow.setAttribute('d', \"M \".concat(centerX, \" \").concat(centerY, \" \") + getArrowBody(scaleArrow));\n  return arrow;\n};\n\n/**\r\n * returns string for creating straight edge for directed graph (with arrow),\r\n * arrow is center on the half of length of the edge, all parameters are described before\r\n */\nvar getArrowForLine = function getArrowForLine(id, x1, y1, x2, y2, edgeSVG, scaleArrow) {\n  var arrow = document.createElementNS(SVG_NS_URI, 'path');\n  arrow.setAttribute('id', \"arrow-id-\".concat(id));\n  arrow.setAttribute('fill', edgeSVG['stroke']);\n  var centerX = (x1 + x2) / 2;\n  var centerY = (y1 + y2) / 2;\n  arrow.setAttribute('d', \"M \".concat(centerX, \" \").concat(centerY, \" \") + getArrowBody(scaleArrow));\n  return arrow;\n};\n/**\r\n *\r\n * @param v1 first vertex that is going to be connected with the second vertex\r\n * @param v2 second vertex\r\n * @param edgeSVG object with SVG customisation attributes\r\n * @param isDirected\r\n * @param isWeighted\r\n * @returns {SVGPathElement}\r\n */\nvar createEdge = function createEdge(v1, v2, edgeSVG, isDirected, isWeighted) {\n  var edge = document.createElementNS(SVG_NS_URI, \"path\");\n  edge.setAttribute(\"fill\", \"none\");\n  // CA (Custom Attribute) - connection consists of ids of vertices that are connected\n  edge.setAttribute('CA-connection', \"\".concat(v1.id, \",\").concat(v2.id));\n  edge.setAttribute('id', \"edge-id-\".concat(edgeIDCounter++));\n  if (v1 === v2) {\n    // loop\n    edge.setAttribute(\"d\", getUndirectedLoop(v1.x, v1.y, edgeSVG['scale-loop'], edgeSVG['scale-loop'] * CIRCLE_SIZE));\n    edge.setAttribute(\"CA-type\", \"loop\");\n    edge.setAttribute(\"CA-loop-angle\", \"0\");\n  } else {\n    // line or arc\n    var args = [v1.x, v1.y, v2.x - v1.x, v2.y - v1.y];\n    var query = \"path[CA-connection=\\\"\".concat(v1.id + ',' + v2.id, \"\\\"], path[CA-connection=\\\"\").concat(v2.id + ',' + v1.id, \"\\\"]\");\n    var edges = Array.from(document.querySelectorAll(query));\n    edges.push(edge);\n    var len = edges.length;\n    if (len > 0) {\n      var e,\n        h,\n        i,\n        j = Math.floor(len / 2);\n      for (i = 0; i < j; i++) {\n        h = ARC_SPACING * (j - i);\n        e = edges[i];\n        e.setAttribute(\"d\", getUndirectedArc.apply(void 0, args.concat([h, false])));\n        e.setAttribute(\"CA-type\", \"arc\");\n        e.setAttribute(\"CA-h\", h.toString());\n        e.setAttribute(\"CA-inv\", \"false\");\n      }\n      if (len % 2 !== 0) {\n        e = edges[i];\n        e.setAttribute(\"d\", getUndirectedLine.apply(void 0, args));\n        e.setAttribute(\"CA-type\", \"line\");\n      }\n      for (i = Math.ceil(len / 2), j = 1; i < len; i++, j++) {\n        h = ARC_SPACING * j;\n        e = edges[i];\n        e.setAttribute(\"d\", getUndirectedArc.apply(void 0, args.concat([h, true])));\n        e.setAttribute(\"CA-type\", \"arc\");\n        e.setAttribute(\"CA-h\", h.toString());\n        e.setAttribute(\"CA-inv\", \"true\");\n      }\n      if (isDirected) {\n        for (i = 0; i < len - 1; i++) {\n          // update all except the new one because it is at the right position,\n          // and it's not added yet so arrow can't be updated\n          (0,_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.updateArrowOnLineMove)((0,_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.getIDFromEdge)(edges[i]), isWeighted);\n        }\n      }\n      if (isWeighted) {\n        for (i = 0; i < len - 1; i++) {\n          var id = (0,_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.getIDFromEdge)(edges[i]);\n          if ((0,_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.getWeightItemFromID)(id) !== null) {\n            // weight item may still not be placed\n            (0,_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_1__.updateWeightOnMove)(id);\n          }\n        }\n      }\n    } else {\n      edge.setAttribute(\"d\", getUndirectedLine.apply(void 0, args));\n      edge.setAttribute(\"CA-type\", \"line\");\n    }\n  }\n  for (var _i2 = 0, _Object$entries2 = Object.entries(edgeSVG); _i2 < _Object$entries2.length; _i2++) {\n    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),\n      key = _Object$entries2$_i[0],\n      value = _Object$entries2$_i[1];\n    edge.setAttribute(\"\".concat(key), \"\".concat(value));\n  }\n  v1.neighbours.push(v2.id);\n  // don't add the same vertex twice if there is a loop\n  if (v1 !== v2) {\n    v2.neighbours.push(v1.id);\n  }\n  return edge;\n};\n\n/**\r\n * removing SVGVertexElements and SVGTextElements and appending them to\r\n * canvas again in order to create proper order (vertex have to be on\r\n * top of edge and text have to be on top of vertex)\r\n */\nvar restore = function restore(v1, v2, t1, t2) {\n  SVG_CANVAS.removeChild(t1);\n  SVG_CANVAS.removeChild(v1);\n  if (v1 !== v2) {\n    SVG_CANVAS.removeChild(t2);\n    SVG_CANVAS.removeChild(v2);\n  }\n  SVG_CANVAS.append(v1, t1);\n  if (v1 !== v2) {\n    SVG_CANVAS.append(v2, t2);\n  }\n};\n\n// manipulate counters from outer scripts, num can be negative\nvar addToVertexIDCounter = function addToVertexIDCounter(num) {\n  return vertexIDCounter += num;\n};\nvar addToEdgeIDCounter = function addToEdgeIDCounter(num) {\n  return edgeIDCounter += num;\n};\n\n\n//# sourceURL=webpack://test_zav/./public/scripts/models/VertexModel.js?");

/***/ }),

/***/ "./public/scripts/utils/traversal.js":
/*!*******************************************!*\
  !*** ./public/scripts/utils/traversal.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"distanceFromLine\": () => (/* binding */ distanceFromLine),\n/* harmony export */   \"fundamentalCycleSet\": () => (/* binding */ fundamentalCycleSet),\n/* harmony export */   \"isConnectedGraph\": () => (/* binding */ isConnectedGraph),\n/* harmony export */   \"isSimpleGraph\": () => (/* binding */ isSimpleGraph),\n/* harmony export */   \"rayCasting\": () => (/* binding */ rayCasting),\n/* harmony export */   \"shoelace\": () => (/* binding */ shoelace)\n/* harmony export */ });\n/* harmony import */ var _models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/DrawingHelperModel.js */ \"./public/scripts/models/DrawingHelperModel.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n\n// source: https://www.codeproject.com/Articles/1158232/Enumerating-All-Cycles-in-an-Undirected-Graph\nfunction fundamentalCycleSet(vertexContainer, v0) {\n  var vertices = structuredClone(vertexContainer);\n  var cycles = [];\n  function traverse(v, start, visited, path) {\n    v.visited = true;\n    path.push(v.id);\n    if (path.length > 2 && start.neighbours.includes(v.id)) {\n      cycles.push(_toConsumableArray(path)); // cycle\n    } else {\n      var _iterator = _createForOfIteratorHelper(vertices),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var u = _step.value;\n          if (u.neighbours.includes(v.id) && !u.visited && u.id !== start.id) {\n            traverse(u, start, visited, path);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    path.pop();\n    v.visited = false;\n  }\n  var visited = new Array(vertices.length).fill(false);\n  var path = [];\n  traverse(v0, v0, visited, path);\n  removeDuplicates(cycles);\n  return removeSupersets(cycles);\n}\nfunction removeDuplicates(arr) {\n  for (var i = arr.length - 1; i >= 0; i--) {\n    for (var j = i - 1; j >= 0; j--) {\n      if (_.isEqual(_.sortBy(arr[i]), _.sortBy(arr[j]))) {\n        // _.sortBy() doesn't mutate the arr\n        arr.splice(i, 1);\n        break;\n      }\n    }\n  }\n}\nfunction removeSupersets(arr) {\n  var result = [];\n  var _loop = function _loop(i) {\n    var isSuperset = false;\n    for (var j = 0; j < arr.length; j++) {\n      if (i === j) {\n        continue;\n      }\n      if (arr[j].every(function (el) {\n        return arr[i].includes(el);\n      })) {\n        isSuperset = true;\n        break;\n      }\n    }\n    if (!isSuperset) {\n      result.push(arr[i]);\n    }\n  };\n  for (var i = 0; i < arr.length; i++) {\n    _loop(i);\n  }\n  return result;\n}\n\n// source: http://paulbourke.net/geometry/pointlineplane/\nfunction distanceFromLine(x1, y1, x2, y2, x, y) {\n  var u = Math.max(0, Math.min(1, ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / (Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2))));\n  return Math.sqrt(Math.pow(x1 + u * (x2 - x1) - x, 2) + Math.pow(y1 + u * (y2 - y1) - y, 2));\n}\n\n// source: https://wrfranklin.org/Research/Short_Notes/pnpoly.html\nfunction rayCasting(polygon, x, y) {\n  var n = polygon.length;\n  var inside = false;\n  for (var i = 0, j = n - 1; i < n; j = i++) {\n    var xi = polygon[i][0];\n    var yi = polygon[i][1];\n    var xj = polygon[j][0];\n    var yj = polygon[j][1];\n    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {\n      inside = !inside;\n    }\n  }\n  return inside;\n}\n\n// source: https://en.wikipedia.org/wiki/Shoelace_formula\nfunction shoelace(polygon) {\n  var n = polygon.length;\n  var area = 0;\n  for (var i = 0; i < n; i++) {\n    var x1 = polygon[i][0];\n    var y1 = polygon[i][1];\n    var x2 = polygon[(i + 1) % n][0];\n    var y2 = polygon[(i + 1) % n][1];\n    area += x1 * y2 - y1 * x2;\n  }\n  return Math.abs(area) / 2;\n}\nfunction isSimpleGraph() {\n  var connections = (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_0__.getAllEdges)().map(function (edge) {\n    return (0,_models_DrawingHelperModel_js__WEBPACK_IMPORTED_MODULE_0__.getConnection)(edge);\n  });\n  for (var i = 0; i < connections.length; i++) {\n    if (connections[i][0] === connections[i][1]) {\n      return false; // loop\n    }\n\n    for (var j = i + 1; j < connections.length; j++) {\n      if (connections[i][0] === connections[j][0] && connections[i][1] === connections[j][1] || connections[i][0] === connections[j][1] && connections[i][1] === connections[j][0]) {\n        return false; // multiple edges\n      }\n    }\n  }\n\n  return true;\n}\nfunction isConnectedGraph(vertexContainer) {\n  if (vertexContainer.length === 0) {\n    return false;\n  }\n  var stack = [vertexContainer[0]];\n  var visited = [];\n  while (stack.length > 0) {\n    var v = stack.pop();\n    var _iterator2 = _createForOfIteratorHelper(v.neighbours),\n      _step2;\n    try {\n      var _loop2 = function _loop2() {\n        var u = _step2.value;\n        u = vertexContainer.find(function (el) {\n          return el.id === u;\n        });\n        if (!visited.includes(u)) {\n          visited.push(u);\n          stack.push(u);\n        }\n      };\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        _loop2();\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n  return vertexContainer.length === visited.length;\n}\n\n//# sourceURL=webpack://test_zav/./public/scripts/utils/traversal.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./public/scripts/drawing.js");
/******/ 	
/******/ })()
;